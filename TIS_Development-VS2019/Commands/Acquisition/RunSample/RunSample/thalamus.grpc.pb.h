// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: thalamus.proto
#ifndef GRPC_thalamus_2eproto__INCLUDED
#define GRPC_thalamus_2eproto__INCLUDED

#include "thalamus.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace thalamus_grpc {

class Thalamus final {
 public:
  static constexpr char const* service_full_name() {
    return "thalamus_grpc.Thalamus";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientWriterInterface< ::thalamus_grpc::Event>> events(::grpc::ClientContext* context, ::util_grpc::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::thalamus_grpc::Event>>(eventsRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Event>> Asyncevents(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Event>>(AsynceventsRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Event>> PrepareAsyncevents(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Event>>(PrepareAsynceventsRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::thalamus_grpc::Text>> log(::grpc::ClientContext* context, ::util_grpc::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::thalamus_grpc::Text>>(logRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Text>> Asynclog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Text>>(AsynclogRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Text>> PrepareAsynclog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Text>>(PrepareAsynclogRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>> observable_bridge(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>>(observable_bridgeRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>> Asyncobservable_bridge(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>>(Asyncobservable_bridgeRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>> PrepareAsyncobservable_bridge(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>>(PrepareAsyncobservable_bridgeRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::GraphResponse>> graph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::GraphResponse>>(graphRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::GraphResponse>> Asyncgraph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::GraphResponse>>(AsyncgraphRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::GraphResponse>> PrepareAsyncgraph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::GraphResponse>>(PrepareAsyncgraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::AnalogResponse>> analog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::AnalogResponse>>(analogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>> Asyncanalog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>>(AsyncanalogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>> PrepareAsyncanalog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>>(PrepareAsyncanalogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::SpectrogramResponse>> spectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::SpectrogramResponse>>(spectrogramRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::SpectrogramResponse>> Asyncspectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::SpectrogramResponse>>(AsyncspectrogramRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::SpectrogramResponse>> PrepareAsyncspectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::SpectrogramResponse>>(PrepareAsyncspectrogramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::AnalogResponse>> channel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::AnalogResponse>>(channel_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>> Asyncchannel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>>(Asyncchannel_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>> PrepareAsyncchannel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>>(PrepareAsyncchannel_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::XsensResponse>> xsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::XsensResponse>>(xsensRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::XsensResponse>> Asyncxsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::XsensResponse>>(AsyncxsensRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::XsensResponse>> PrepareAsyncxsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::XsensResponse>>(PrepareAsyncxsensRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::Image>> image(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::Image>>(imageRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Image>> Asyncimage(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Image>>(AsyncimageRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Image>> PrepareAsyncimage(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Image>>(PrepareAsyncimageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>> eval(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>>(evalRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>> Asynceval(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>>(AsyncevalRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>> PrepareAsynceval(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>>(PrepareAsyncevalRaw(context, cq));
    }
    virtual ::grpc::Status get_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::thalamus_grpc::StringMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringMessage>> Asyncget_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringMessage>>(Asyncget_type_nameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringMessage>> PrepareAsyncget_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringMessage>>(PrepareAsyncget_type_nameRaw(context, request, cq));
    }
    virtual ::grpc::Status get_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::thalamus_grpc::StringListMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringListMessage>> Asyncget_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringListMessage>>(Asyncget_recommended_channelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringListMessage>> PrepareAsyncget_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringListMessage>>(PrepareAsyncget_recommended_channelsRaw(context, request, cq));
    }
    virtual ::grpc::Status replay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::util_grpc::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::util_grpc::Empty>> Asyncreplay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::util_grpc::Empty>>(AsyncreplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::util_grpc::Empty>> PrepareAsyncreplay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::util_grpc::Empty>>(PrepareAsyncreplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>> remote_node(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>>(remote_nodeRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>> Asyncremote_node(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>>(Asyncremote_nodeRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>> PrepareAsyncremote_node(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>>(PrepareAsyncremote_nodeRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::Notification>> notification(::grpc::ClientContext* context, const ::util_grpc::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::thalamus_grpc::Notification>>(notificationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Notification>> Asyncnotification(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Notification>>(AsyncnotificationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Notification>> PrepareAsyncnotification(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Notification>>(PrepareAsyncnotificationRaw(context, request, cq));
    }
    virtual ::grpc::Status node_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::thalamus_grpc::NodeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::NodeResponse>> Asyncnode_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::NodeResponse>>(Asyncnode_requestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::NodeResponse>> PrepareAsyncnode_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::NodeResponse>>(PrepareAsyncnode_requestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriterInterface< ::thalamus_grpc::InjectAnalogRequest>> inject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriterInterface< ::thalamus_grpc::InjectAnalogRequest>>(inject_analogRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::InjectAnalogRequest>> Asyncinject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::InjectAnalogRequest>>(Asyncinject_analogRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::InjectAnalogRequest>> PrepareAsyncinject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::InjectAnalogRequest>>(PrepareAsyncinject_analogRaw(context, response, cq));
    }
    virtual ::grpc::Status get_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::thalamus_grpc::ModalitiesMessage* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::ModalitiesMessage>> Asyncget_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::ModalitiesMessage>>(Asyncget_modalitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::ModalitiesMessage>> PrepareAsyncget_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::ModalitiesMessage>>(PrepareAsyncget_modalitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>> ping(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>>(pingRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>> Asyncping(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>>(AsyncpingRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>> PrepareAsyncping(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>>(PrepareAsyncpingRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>> inject_text(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>>(inject_textRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>> Asyncinject_text(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>>(Asyncinject_textRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>> PrepareAsyncinject_text(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>>(PrepareAsyncinject_textRaw(context, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void events(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::ClientWriteReactor< ::thalamus_grpc::Event>* reactor) = 0;
      virtual void log(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::ClientWriteReactor< ::thalamus_grpc::Text>* reactor) = 0;
      virtual void observable_bridge(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::ObservableChange,::thalamus_grpc::ObservableChange>* reactor) = 0;
      virtual void graph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::GraphResponse>* reactor) = 0;
      virtual void analog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::AnalogResponse>* reactor) = 0;
      virtual void spectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::SpectrogramResponse>* reactor) = 0;
      virtual void channel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::AnalogResponse>* reactor) = 0;
      virtual void xsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::grpc::ClientReadReactor< ::thalamus_grpc::XsensResponse>* reactor) = 0;
      virtual void image(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::Image>* reactor) = 0;
      virtual void eval(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::EvalResponse,::thalamus_grpc::EvalRequest>* reactor) = 0;
      virtual void get_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage* request, ::thalamus_grpc::StringMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage* request, ::thalamus_grpc::StringMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void get_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::StringListMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::StringListMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void replay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest* request, ::util_grpc::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void replay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest* request, ::util_grpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void remote_node(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::RemoteNodeMessage,::thalamus_grpc::RemoteNodeMessage>* reactor) = 0;
      virtual void notification(::grpc::ClientContext* context, const ::util_grpc::Empty* request, ::grpc::ClientReadReactor< ::thalamus_grpc::Notification>* reactor) = 0;
      virtual void node_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest* request, ::thalamus_grpc::NodeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void node_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest* request, ::thalamus_grpc::NodeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void inject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::ClientWriteReactor< ::thalamus_grpc::InjectAnalogRequest>* reactor) = 0;
      virtual void get_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::ModalitiesMessage* response, std::function<void(::grpc::Status)>) = 0;
      virtual void get_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::ModalitiesMessage* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ping(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::Ping,::thalamus_grpc::Pong>* reactor) = 0;
      virtual void inject_text(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::InjectTextRequest,::thalamus_grpc::Pong>* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientWriterInterface< ::thalamus_grpc::Event>* eventsRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Event>* AsynceventsRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Event>* PrepareAsynceventsRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::thalamus_grpc::Text>* logRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Text>* AsynclogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::Text>* PrepareAsynclogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* observable_bridgeRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* Asyncobservable_bridgeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* PrepareAsyncobservable_bridgeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::GraphResponse>* graphRaw(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::GraphResponse>* AsyncgraphRaw(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::GraphResponse>* PrepareAsyncgraphRaw(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::AnalogResponse>* analogRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>* AsyncanalogRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>* PrepareAsyncanalogRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::SpectrogramResponse>* spectrogramRaw(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::SpectrogramResponse>* AsyncspectrogramRaw(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::SpectrogramResponse>* PrepareAsyncspectrogramRaw(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::AnalogResponse>* channel_infoRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>* Asyncchannel_infoRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::AnalogResponse>* PrepareAsyncchannel_infoRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::XsensResponse>* xsensRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::XsensResponse>* AsyncxsensRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::XsensResponse>* PrepareAsyncxsensRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::Image>* imageRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Image>* AsyncimageRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Image>* PrepareAsyncimageRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* evalRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* AsyncevalRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* PrepareAsyncevalRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringMessage>* Asyncget_type_nameRaw(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringMessage>* PrepareAsyncget_type_nameRaw(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringListMessage>* Asyncget_recommended_channelsRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::StringListMessage>* PrepareAsyncget_recommended_channelsRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::util_grpc::Empty>* AsyncreplayRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::util_grpc::Empty>* PrepareAsyncreplayRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* remote_nodeRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* Asyncremote_nodeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* PrepareAsyncremote_nodeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::thalamus_grpc::Notification>* notificationRaw(::grpc::ClientContext* context, const ::util_grpc::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Notification>* AsyncnotificationRaw(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::thalamus_grpc::Notification>* PrepareAsyncnotificationRaw(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::NodeResponse>* Asyncnode_requestRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::NodeResponse>* PrepareAsyncnode_requestRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientWriterInterface< ::thalamus_grpc::InjectAnalogRequest>* inject_analogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::InjectAnalogRequest>* Asyncinject_analogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncWriterInterface< ::thalamus_grpc::InjectAnalogRequest>* PrepareAsyncinject_analogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::ModalitiesMessage>* Asyncget_modalitiesRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::thalamus_grpc::ModalitiesMessage>* PrepareAsyncget_modalitiesRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* pingRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* AsyncpingRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* PrepareAsyncpingRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* inject_textRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* Asyncinject_textRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* PrepareAsyncinject_textRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientWriter< ::thalamus_grpc::Event>> events(::grpc::ClientContext* context, ::util_grpc::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::thalamus_grpc::Event>>(eventsRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Event>> Asyncevents(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Event>>(AsynceventsRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Event>> PrepareAsyncevents(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Event>>(PrepareAsynceventsRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::thalamus_grpc::Text>> log(::grpc::ClientContext* context, ::util_grpc::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::thalamus_grpc::Text>>(logRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Text>> Asynclog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Text>>(AsynclogRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Text>> PrepareAsynclog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::Text>>(PrepareAsynclogRaw(context, response, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>> observable_bridge(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>>(observable_bridgeRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>> Asyncobservable_bridge(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>>(Asyncobservable_bridgeRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>> PrepareAsyncobservable_bridge(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>>(PrepareAsyncobservable_bridgeRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::GraphResponse>> graph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::GraphResponse>>(graphRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::GraphResponse>> Asyncgraph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::GraphResponse>>(AsyncgraphRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::GraphResponse>> PrepareAsyncgraph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::GraphResponse>>(PrepareAsyncgraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::AnalogResponse>> analog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::AnalogResponse>>(analogRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>> Asyncanalog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>>(AsyncanalogRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>> PrepareAsyncanalog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>>(PrepareAsyncanalogRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::SpectrogramResponse>> spectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::SpectrogramResponse>>(spectrogramRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::SpectrogramResponse>> Asyncspectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::SpectrogramResponse>>(AsyncspectrogramRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::SpectrogramResponse>> PrepareAsyncspectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::SpectrogramResponse>>(PrepareAsyncspectrogramRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::AnalogResponse>> channel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::AnalogResponse>>(channel_infoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>> Asyncchannel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>>(Asyncchannel_infoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>> PrepareAsyncchannel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>>(PrepareAsyncchannel_infoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::XsensResponse>> xsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::XsensResponse>>(xsensRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::XsensResponse>> Asyncxsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::XsensResponse>>(AsyncxsensRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::XsensResponse>> PrepareAsyncxsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::XsensResponse>>(PrepareAsyncxsensRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::Image>> image(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::Image>>(imageRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Image>> Asyncimage(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Image>>(AsyncimageRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Image>> PrepareAsyncimage(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Image>>(PrepareAsyncimageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>> eval(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>>(evalRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>> Asynceval(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>>(AsyncevalRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>> PrepareAsynceval(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>>(PrepareAsyncevalRaw(context, cq));
    }
    ::grpc::Status get_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::thalamus_grpc::StringMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringMessage>> Asyncget_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringMessage>>(Asyncget_type_nameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringMessage>> PrepareAsyncget_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringMessage>>(PrepareAsyncget_type_nameRaw(context, request, cq));
    }
    ::grpc::Status get_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::thalamus_grpc::StringListMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringListMessage>> Asyncget_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringListMessage>>(Asyncget_recommended_channelsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringListMessage>> PrepareAsyncget_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringListMessage>>(PrepareAsyncget_recommended_channelsRaw(context, request, cq));
    }
    ::grpc::Status replay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::util_grpc::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::util_grpc::Empty>> Asyncreplay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::util_grpc::Empty>>(AsyncreplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::util_grpc::Empty>> PrepareAsyncreplay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::util_grpc::Empty>>(PrepareAsyncreplayRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>> remote_node(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>>(remote_nodeRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>> Asyncremote_node(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>>(Asyncremote_nodeRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>> PrepareAsyncremote_node(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>>(PrepareAsyncremote_nodeRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::Notification>> notification(::grpc::ClientContext* context, const ::util_grpc::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::thalamus_grpc::Notification>>(notificationRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Notification>> Asyncnotification(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Notification>>(AsyncnotificationRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Notification>> PrepareAsyncnotification(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::thalamus_grpc::Notification>>(PrepareAsyncnotificationRaw(context, request, cq));
    }
    ::grpc::Status node_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::thalamus_grpc::NodeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::NodeResponse>> Asyncnode_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::NodeResponse>>(Asyncnode_requestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::NodeResponse>> PrepareAsyncnode_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::NodeResponse>>(PrepareAsyncnode_requestRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientWriter< ::thalamus_grpc::InjectAnalogRequest>> inject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response) {
      return std::unique_ptr< ::grpc::ClientWriter< ::thalamus_grpc::InjectAnalogRequest>>(inject_analogRaw(context, response));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::InjectAnalogRequest>> Asyncinject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::InjectAnalogRequest>>(Asyncinject_analogRaw(context, response, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::InjectAnalogRequest>> PrepareAsyncinject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncWriter< ::thalamus_grpc::InjectAnalogRequest>>(PrepareAsyncinject_analogRaw(context, response, cq));
    }
    ::grpc::Status get_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::thalamus_grpc::ModalitiesMessage* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::ModalitiesMessage>> Asyncget_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::ModalitiesMessage>>(Asyncget_modalitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::ModalitiesMessage>> PrepareAsyncget_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::ModalitiesMessage>>(PrepareAsyncget_modalitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>> ping(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>>(pingRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>> Asyncping(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>>(AsyncpingRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>> PrepareAsyncping(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>>(PrepareAsyncpingRaw(context, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>> inject_text(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>>(inject_textRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>> Asyncinject_text(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>>(Asyncinject_textRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>> PrepareAsyncinject_text(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>>(PrepareAsyncinject_textRaw(context, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void events(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::ClientWriteReactor< ::thalamus_grpc::Event>* reactor) override;
      void log(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::ClientWriteReactor< ::thalamus_grpc::Text>* reactor) override;
      void observable_bridge(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::ObservableChange,::thalamus_grpc::ObservableChange>* reactor) override;
      void graph(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::GraphResponse>* reactor) override;
      void analog(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::AnalogResponse>* reactor) override;
      void spectrogram(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::SpectrogramResponse>* reactor) override;
      void channel_info(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::AnalogResponse>* reactor) override;
      void xsens(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::grpc::ClientReadReactor< ::thalamus_grpc::XsensResponse>* reactor) override;
      void image(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest* request, ::grpc::ClientReadReactor< ::thalamus_grpc::Image>* reactor) override;
      void eval(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::EvalResponse,::thalamus_grpc::EvalRequest>* reactor) override;
      void get_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage* request, ::thalamus_grpc::StringMessage* response, std::function<void(::grpc::Status)>) override;
      void get_type_name(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage* request, ::thalamus_grpc::StringMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      void get_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::StringListMessage* response, std::function<void(::grpc::Status)>) override;
      void get_recommended_channels(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::StringListMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      void replay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest* request, ::util_grpc::Empty* response, std::function<void(::grpc::Status)>) override;
      void replay(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest* request, ::util_grpc::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void remote_node(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::RemoteNodeMessage,::thalamus_grpc::RemoteNodeMessage>* reactor) override;
      void notification(::grpc::ClientContext* context, const ::util_grpc::Empty* request, ::grpc::ClientReadReactor< ::thalamus_grpc::Notification>* reactor) override;
      void node_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest* request, ::thalamus_grpc::NodeResponse* response, std::function<void(::grpc::Status)>) override;
      void node_request(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest* request, ::thalamus_grpc::NodeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void inject_analog(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::ClientWriteReactor< ::thalamus_grpc::InjectAnalogRequest>* reactor) override;
      void get_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::ModalitiesMessage* response, std::function<void(::grpc::Status)>) override;
      void get_modalities(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::ModalitiesMessage* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ping(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::Ping,::thalamus_grpc::Pong>* reactor) override;
      void inject_text(::grpc::ClientContext* context, ::grpc::ClientBidiReactor< ::thalamus_grpc::InjectTextRequest,::thalamus_grpc::Pong>* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientWriter< ::thalamus_grpc::Event>* eventsRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::thalamus_grpc::Event>* AsynceventsRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::thalamus_grpc::Event>* PrepareAsynceventsRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::thalamus_grpc::Text>* logRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::thalamus_grpc::Text>* AsynclogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::thalamus_grpc::Text>* PrepareAsynclogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* observable_bridgeRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* Asyncobservable_bridgeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* PrepareAsyncobservable_bridgeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::GraphResponse>* graphRaw(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::GraphResponse>* AsyncgraphRaw(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::GraphResponse>* PrepareAsyncgraphRaw(::grpc::ClientContext* context, const ::thalamus_grpc::GraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::AnalogResponse>* analogRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>* AsyncanalogRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>* PrepareAsyncanalogRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::SpectrogramResponse>* spectrogramRaw(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::SpectrogramResponse>* AsyncspectrogramRaw(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::SpectrogramResponse>* PrepareAsyncspectrogramRaw(::grpc::ClientContext* context, const ::thalamus_grpc::SpectrogramRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::AnalogResponse>* channel_infoRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>* Asyncchannel_infoRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::AnalogResponse>* PrepareAsyncchannel_infoRaw(::grpc::ClientContext* context, const ::thalamus_grpc::AnalogRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::XsensResponse>* xsensRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::XsensResponse>* AsyncxsensRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::XsensResponse>* PrepareAsyncxsensRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::Image>* imageRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::Image>* AsyncimageRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::Image>* PrepareAsyncimageRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ImageRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* evalRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* AsyncevalRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* PrepareAsyncevalRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringMessage>* Asyncget_type_nameRaw(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringMessage>* PrepareAsyncget_type_nameRaw(::grpc::ClientContext* context, const ::thalamus_grpc::StringMessage& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringListMessage>* Asyncget_recommended_channelsRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::StringListMessage>* PrepareAsyncget_recommended_channelsRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::util_grpc::Empty>* AsyncreplayRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::util_grpc::Empty>* PrepareAsyncreplayRaw(::grpc::ClientContext* context, const ::thalamus_grpc::ReplayRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* remote_nodeRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* Asyncremote_nodeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* PrepareAsyncremote_nodeRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::thalamus_grpc::Notification>* notificationRaw(::grpc::ClientContext* context, const ::util_grpc::Empty& request) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::Notification>* AsyncnotificationRaw(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::thalamus_grpc::Notification>* PrepareAsyncnotificationRaw(::grpc::ClientContext* context, const ::util_grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::NodeResponse>* Asyncnode_requestRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::NodeResponse>* PrepareAsyncnode_requestRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientWriter< ::thalamus_grpc::InjectAnalogRequest>* inject_analogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response) override;
    ::grpc::ClientAsyncWriter< ::thalamus_grpc::InjectAnalogRequest>* Asyncinject_analogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncWriter< ::thalamus_grpc::InjectAnalogRequest>* PrepareAsyncinject_analogRaw(::grpc::ClientContext* context, ::util_grpc::Empty* response, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::ModalitiesMessage>* Asyncget_modalitiesRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::thalamus_grpc::ModalitiesMessage>* PrepareAsyncget_modalitiesRaw(::grpc::ClientContext* context, const ::thalamus_grpc::NodeSelector& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* pingRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* AsyncpingRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* PrepareAsyncpingRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* inject_textRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* Asyncinject_textRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* PrepareAsyncinject_textRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_events_;
    const ::grpc::internal::RpcMethod rpcmethod_log_;
    const ::grpc::internal::RpcMethod rpcmethod_observable_bridge_;
    const ::grpc::internal::RpcMethod rpcmethod_graph_;
    const ::grpc::internal::RpcMethod rpcmethod_analog_;
    const ::grpc::internal::RpcMethod rpcmethod_spectrogram_;
    const ::grpc::internal::RpcMethod rpcmethod_channel_info_;
    const ::grpc::internal::RpcMethod rpcmethod_xsens_;
    const ::grpc::internal::RpcMethod rpcmethod_image_;
    const ::grpc::internal::RpcMethod rpcmethod_eval_;
    const ::grpc::internal::RpcMethod rpcmethod_get_type_name_;
    const ::grpc::internal::RpcMethod rpcmethod_get_recommended_channels_;
    const ::grpc::internal::RpcMethod rpcmethod_replay_;
    const ::grpc::internal::RpcMethod rpcmethod_remote_node_;
    const ::grpc::internal::RpcMethod rpcmethod_notification_;
    const ::grpc::internal::RpcMethod rpcmethod_node_request_;
    const ::grpc::internal::RpcMethod rpcmethod_inject_analog_;
    const ::grpc::internal::RpcMethod rpcmethod_get_modalities_;
    const ::grpc::internal::RpcMethod rpcmethod_ping_;
    const ::grpc::internal::RpcMethod rpcmethod_inject_text_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status events(::grpc::ServerContext* context, ::grpc::ServerReader< ::thalamus_grpc::Event>* reader, ::util_grpc::Empty* response);
    virtual ::grpc::Status log(::grpc::ServerContext* context, ::grpc::ServerReader< ::thalamus_grpc::Text>* reader, ::util_grpc::Empty* response);
    virtual ::grpc::Status observable_bridge(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* stream);
    virtual ::grpc::Status graph(::grpc::ServerContext* context, const ::thalamus_grpc::GraphRequest* request, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* writer);
    virtual ::grpc::Status analog(::grpc::ServerContext* context, const ::thalamus_grpc::AnalogRequest* request, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* writer);
    virtual ::grpc::Status spectrogram(::grpc::ServerContext* context, const ::thalamus_grpc::SpectrogramRequest* request, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* writer);
    virtual ::grpc::Status channel_info(::grpc::ServerContext* context, const ::thalamus_grpc::AnalogRequest* request, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* writer);
    virtual ::grpc::Status xsens(::grpc::ServerContext* context, const ::thalamus_grpc::NodeSelector* request, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* writer);
    virtual ::grpc::Status image(::grpc::ServerContext* context, const ::thalamus_grpc::ImageRequest* request, ::grpc::ServerWriter< ::thalamus_grpc::Image>* writer);
    virtual ::grpc::Status eval(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* stream);
    virtual ::grpc::Status get_type_name(::grpc::ServerContext* context, const ::thalamus_grpc::StringMessage* request, ::thalamus_grpc::StringMessage* response);
    virtual ::grpc::Status get_recommended_channels(::grpc::ServerContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::StringListMessage* response);
    virtual ::grpc::Status replay(::grpc::ServerContext* context, const ::thalamus_grpc::ReplayRequest* request, ::util_grpc::Empty* response);
    virtual ::grpc::Status remote_node(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* stream);
    virtual ::grpc::Status notification(::grpc::ServerContext* context, const ::util_grpc::Empty* request, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* writer);
    virtual ::grpc::Status node_request(::grpc::ServerContext* context, const ::thalamus_grpc::NodeRequest* request, ::thalamus_grpc::NodeResponse* response);
    virtual ::grpc::Status inject_analog(::grpc::ServerContext* context, ::grpc::ServerReader< ::thalamus_grpc::InjectAnalogRequest>* reader, ::util_grpc::Empty* response);
    virtual ::grpc::Status get_modalities(::grpc::ServerContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::ModalitiesMessage* response);
    virtual ::grpc::Status ping(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* stream);
    virtual ::grpc::Status inject_text(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* stream);
  };
  template <class BaseClass>
  class WithAsyncMethod_events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_events() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status events(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Event>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestevents(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::util_grpc::Empty, ::thalamus_grpc::Event>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_log() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status log(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Text>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlog(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::util_grpc::Empty, ::thalamus_grpc::Text>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_observable_bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_observable_bridge() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_observable_bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status observable_bridge(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestobservable_bridge(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_graph() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgraph(::grpc::ServerContext* context, ::thalamus_grpc::GraphRequest* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::GraphResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_analog() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status analog(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestanalog(::grpc::ServerContext* context, ::thalamus_grpc::AnalogRequest* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::AnalogResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_spectrogram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_spectrogram() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_spectrogram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status spectrogram(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestspectrogram(::grpc::ServerContext* context, ::thalamus_grpc::SpectrogramRequest* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::SpectrogramResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_channel_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_channel_info() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_channel_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel_info(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestchannel_info(::grpc::ServerContext* context, ::thalamus_grpc::AnalogRequest* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::AnalogResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_xsens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_xsens() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_xsens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status xsens(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestxsens(::grpc::ServerContext* context, ::thalamus_grpc::NodeSelector* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::XsensResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_image() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimage(::grpc::ServerContext* context, ::thalamus_grpc::ImageRequest* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::Image>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_eval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_eval() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_eval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesteval(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(9, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_type_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_type_name() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_get_type_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_type_name(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_type_name(::grpc::ServerContext* context, ::thalamus_grpc::StringMessage* request, ::grpc::ServerAsyncResponseWriter< ::thalamus_grpc::StringMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_recommended_channels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_recommended_channels() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_get_recommended_channels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_recommended_channels(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_recommended_channels(::grpc::ServerContext* context, ::thalamus_grpc::NodeSelector* request, ::grpc::ServerAsyncResponseWriter< ::thalamus_grpc::StringListMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_replay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_replay() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_replay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status replay(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreplay(::grpc::ServerContext* context, ::thalamus_grpc::ReplayRequest* request, ::grpc::ServerAsyncResponseWriter< ::util_grpc::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_remote_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_remote_node() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_remote_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_node(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_node(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(13, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_notification : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_notification() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_notification() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status notification(::grpc::ServerContext* /*context*/, const ::util_grpc::Empty* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnotification(::grpc::ServerContext* context, ::util_grpc::Empty* request, ::grpc::ServerAsyncWriter< ::thalamus_grpc::Notification>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_node_request : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_node_request() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_node_request() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status node_request(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnode_request(::grpc::ServerContext* context, ::thalamus_grpc::NodeRequest* request, ::grpc::ServerAsyncResponseWriter< ::thalamus_grpc::NodeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_inject_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_inject_analog() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_inject_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_analog(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::InjectAnalogRequest>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinject_analog(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::util_grpc::Empty, ::thalamus_grpc::InjectAnalogRequest>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(16, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_get_modalities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_get_modalities() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_get_modalities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_modalities(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_modalities(::grpc::ServerContext* context, ::thalamus_grpc::NodeSelector* request, ::grpc::ServerAsyncResponseWriter< ::thalamus_grpc::ModalitiesMessage>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ping() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestping(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(18, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_inject_text : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_inject_text() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_inject_text() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_text(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinject_text(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(19, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_events<WithAsyncMethod_log<WithAsyncMethod_observable_bridge<WithAsyncMethod_graph<WithAsyncMethod_analog<WithAsyncMethod_spectrogram<WithAsyncMethod_channel_info<WithAsyncMethod_xsens<WithAsyncMethod_image<WithAsyncMethod_eval<WithAsyncMethod_get_type_name<WithAsyncMethod_get_recommended_channels<WithAsyncMethod_replay<WithAsyncMethod_remote_node<WithAsyncMethod_notification<WithAsyncMethod_node_request<WithAsyncMethod_inject_analog<WithAsyncMethod_get_modalities<WithAsyncMethod_ping<WithAsyncMethod_inject_text<Service > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_events() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackClientStreamingHandler< ::thalamus_grpc::Event, ::util_grpc::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, ::util_grpc::Empty* response) { return this->events(context, response); }));
    }
    ~WithCallbackMethod_events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status events(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Event>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::thalamus_grpc::Event>* events(
      ::grpc::CallbackServerContext* /*context*/, ::util_grpc::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_log() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackClientStreamingHandler< ::thalamus_grpc::Text, ::util_grpc::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, ::util_grpc::Empty* response) { return this->log(context, response); }));
    }
    ~WithCallbackMethod_log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status log(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Text>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::thalamus_grpc::Text>* log(
      ::grpc::CallbackServerContext* /*context*/, ::util_grpc::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_observable_bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_observable_bridge() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackBidiHandler< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->observable_bridge(context); }));
    }
    ~WithCallbackMethod_observable_bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status observable_bridge(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* observable_bridge(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_graph() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::thalamus_grpc::GraphRequest, ::thalamus_grpc::GraphResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::GraphRequest* request) { return this->graph(context, request); }));
    }
    ~WithCallbackMethod_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::GraphResponse>* graph(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_analog() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::thalamus_grpc::AnalogRequest, ::thalamus_grpc::AnalogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::AnalogRequest* request) { return this->analog(context, request); }));
    }
    ~WithCallbackMethod_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status analog(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::AnalogResponse>* analog(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_spectrogram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_spectrogram() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::thalamus_grpc::SpectrogramRequest, ::thalamus_grpc::SpectrogramResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::SpectrogramRequest* request) { return this->spectrogram(context, request); }));
    }
    ~WithCallbackMethod_spectrogram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status spectrogram(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::SpectrogramResponse>* spectrogram(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_channel_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_channel_info() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::thalamus_grpc::AnalogRequest, ::thalamus_grpc::AnalogResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::AnalogRequest* request) { return this->channel_info(context, request); }));
    }
    ~WithCallbackMethod_channel_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel_info(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::AnalogResponse>* channel_info(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_xsens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_xsens() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::XsensResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::NodeSelector* request) { return this->xsens(context, request); }));
    }
    ~WithCallbackMethod_xsens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status xsens(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::XsensResponse>* xsens(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_image() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::thalamus_grpc::ImageRequest, ::thalamus_grpc::Image>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::ImageRequest* request) { return this->image(context, request); }));
    }
    ~WithCallbackMethod_image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::Image>* image(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_eval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_eval() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackBidiHandler< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->eval(context); }));
    }
    ~WithCallbackMethod_eval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::thalamus_grpc::EvalResponse, ::thalamus_grpc::EvalRequest>* eval(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_type_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_type_name() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::StringMessage, ::thalamus_grpc::StringMessage>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::StringMessage* request, ::thalamus_grpc::StringMessage* response) { return this->get_type_name(context, request, response); }));}
    void SetMessageAllocatorFor_get_type_name(
        ::grpc::MessageAllocator< ::thalamus_grpc::StringMessage, ::thalamus_grpc::StringMessage>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::StringMessage, ::thalamus_grpc::StringMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_type_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_type_name(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_type_name(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_recommended_channels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_recommended_channels() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::StringListMessage>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::StringListMessage* response) { return this->get_recommended_channels(context, request, response); }));}
    void SetMessageAllocatorFor_get_recommended_channels(
        ::grpc::MessageAllocator< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::StringListMessage>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::StringListMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_recommended_channels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_recommended_channels(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_recommended_channels(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_replay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_replay() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::ReplayRequest, ::util_grpc::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::ReplayRequest* request, ::util_grpc::Empty* response) { return this->replay(context, request, response); }));}
    void SetMessageAllocatorFor_replay(
        ::grpc::MessageAllocator< ::thalamus_grpc::ReplayRequest, ::util_grpc::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::ReplayRequest, ::util_grpc::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_replay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status replay(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* replay(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_remote_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_remote_node() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackBidiHandler< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->remote_node(context); }));
    }
    ~WithCallbackMethod_remote_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_node(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* remote_node(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_notification : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_notification() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackServerStreamingHandler< ::util_grpc::Empty, ::thalamus_grpc::Notification>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::util_grpc::Empty* request) { return this->notification(context, request); }));
    }
    ~WithCallbackMethod_notification() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status notification(::grpc::ServerContext* /*context*/, const ::util_grpc::Empty* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::thalamus_grpc::Notification>* notification(
      ::grpc::CallbackServerContext* /*context*/, const ::util_grpc::Empty* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_node_request : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_node_request() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::NodeRequest, ::thalamus_grpc::NodeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::NodeRequest* request, ::thalamus_grpc::NodeResponse* response) { return this->node_request(context, request, response); }));}
    void SetMessageAllocatorFor_node_request(
        ::grpc::MessageAllocator< ::thalamus_grpc::NodeRequest, ::thalamus_grpc::NodeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::NodeRequest, ::thalamus_grpc::NodeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_node_request() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status node_request(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* node_request(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_inject_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_inject_analog() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackClientStreamingHandler< ::thalamus_grpc::InjectAnalogRequest, ::util_grpc::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, ::util_grpc::Empty* response) { return this->inject_analog(context, response); }));
    }
    ~WithCallbackMethod_inject_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_analog(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::InjectAnalogRequest>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::thalamus_grpc::InjectAnalogRequest>* inject_analog(
      ::grpc::CallbackServerContext* /*context*/, ::util_grpc::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_get_modalities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_get_modalities() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::ModalitiesMessage>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::thalamus_grpc::NodeSelector* request, ::thalamus_grpc::ModalitiesMessage* response) { return this->get_modalities(context, request, response); }));}
    void SetMessageAllocatorFor_get_modalities(
        ::grpc::MessageAllocator< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::ModalitiesMessage>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::thalamus_grpc::NodeSelector, ::thalamus_grpc::ModalitiesMessage>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_get_modalities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_modalities(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_modalities(
      ::grpc::CallbackServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ping() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackBidiHandler< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->ping(context); }));
    }
    ~WithCallbackMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::thalamus_grpc::Ping, ::thalamus_grpc::Pong>* ping(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_inject_text : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_inject_text() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackBidiHandler< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->inject_text(context); }));
    }
    ~WithCallbackMethod_inject_text() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_text(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::thalamus_grpc::InjectTextRequest, ::thalamus_grpc::Pong>* inject_text(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  typedef WithCallbackMethod_events<WithCallbackMethod_log<WithCallbackMethod_observable_bridge<WithCallbackMethod_graph<WithCallbackMethod_analog<WithCallbackMethod_spectrogram<WithCallbackMethod_channel_info<WithCallbackMethod_xsens<WithCallbackMethod_image<WithCallbackMethod_eval<WithCallbackMethod_get_type_name<WithCallbackMethod_get_recommended_channels<WithCallbackMethod_replay<WithCallbackMethod_remote_node<WithCallbackMethod_notification<WithCallbackMethod_node_request<WithCallbackMethod_inject_analog<WithCallbackMethod_get_modalities<WithCallbackMethod_ping<WithCallbackMethod_inject_text<Service > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_events() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status events(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Event>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_log() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status log(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Text>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_observable_bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_observable_bridge() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_observable_bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status observable_bridge(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_graph() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_analog() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status analog(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_spectrogram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_spectrogram() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_spectrogram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status spectrogram(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_channel_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_channel_info() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_channel_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel_info(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_xsens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_xsens() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_xsens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status xsens(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_image() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_eval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_eval() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_eval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_type_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_type_name() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_get_type_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_type_name(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_recommended_channels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_recommended_channels() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_get_recommended_channels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_recommended_channels(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_replay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_replay() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_replay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status replay(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_remote_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_remote_node() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_remote_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_node(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_notification : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_notification() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_notification() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status notification(::grpc::ServerContext* /*context*/, const ::util_grpc::Empty* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_node_request : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_node_request() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_node_request() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status node_request(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_inject_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_inject_analog() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_inject_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_analog(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::InjectAnalogRequest>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_get_modalities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_get_modalities() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_get_modalities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_modalities(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ping() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_inject_text : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_inject_text() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_inject_text() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_text(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_events() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status events(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Event>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestevents(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(0, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_log() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status log(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Text>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestlog(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(1, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_observable_bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_observable_bridge() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_observable_bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status observable_bridge(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestobservable_bridge(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(2, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_graph() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestgraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(3, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_analog() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status analog(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestanalog(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(4, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_spectrogram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_spectrogram() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_spectrogram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status spectrogram(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestspectrogram(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_channel_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_channel_info() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_channel_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel_info(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestchannel_info(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(6, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_xsens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_xsens() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_xsens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status xsens(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestxsens(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(7, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_image() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestimage(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(8, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_eval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_eval() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_eval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requesteval(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(9, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_type_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_type_name() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_get_type_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_type_name(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_type_name(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_recommended_channels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_recommended_channels() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_get_recommended_channels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_recommended_channels(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_recommended_channels(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_replay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_replay() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_replay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status replay(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestreplay(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_remote_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_remote_node() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_remote_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_node(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestremote_node(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(13, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_notification : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_notification() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_notification() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status notification(::grpc::ServerContext* /*context*/, const ::util_grpc::Empty* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnotification(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(14, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_node_request : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_node_request() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_node_request() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status node_request(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestnode_request(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_inject_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_inject_analog() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_inject_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_analog(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::InjectAnalogRequest>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinject_analog(::grpc::ServerContext* context, ::grpc::ServerAsyncReader< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* reader, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncClientStreaming(16, context, reader, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_get_modalities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_get_modalities() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_get_modalities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_modalities(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestget_modalities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ping() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestping(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(18, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_inject_text : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_inject_text() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_inject_text() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_text(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestinject_text(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(19, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_events : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_events() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->events(context, response); }));
    }
    ~WithRawCallbackMethod_events() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status events(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Event>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* events(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_log : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_log() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->log(context, response); }));
    }
    ~WithRawCallbackMethod_log() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status log(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::Text>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* log(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_observable_bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_observable_bridge() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->observable_bridge(context); }));
    }
    ~WithRawCallbackMethod_observable_bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status observable_bridge(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::ObservableChange, ::thalamus_grpc::ObservableChange>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* observable_bridge(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_graph() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->graph(context, request); }));
    }
    ~WithRawCallbackMethod_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status graph(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* graph(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_analog() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->analog(context, request); }));
    }
    ~WithRawCallbackMethod_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status analog(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* analog(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_spectrogram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_spectrogram() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->spectrogram(context, request); }));
    }
    ~WithRawCallbackMethod_spectrogram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status spectrogram(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* spectrogram(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_channel_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_channel_info() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->channel_info(context, request); }));
    }
    ~WithRawCallbackMethod_channel_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status channel_info(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* channel_info(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_xsens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_xsens() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->xsens(context, request); }));
    }
    ~WithRawCallbackMethod_xsens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status xsens(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* xsens(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_image() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->image(context, request); }));
    }
    ~WithRawCallbackMethod_image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status image(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* image(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_eval : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_eval() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->eval(context); }));
    }
    ~WithRawCallbackMethod_eval() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status eval(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::EvalRequest, ::thalamus_grpc::EvalResponse>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* eval(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_type_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_type_name() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_type_name(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_type_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_type_name(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_type_name(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_recommended_channels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_recommended_channels() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_recommended_channels(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_recommended_channels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_recommended_channels(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_recommended_channels(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_replay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_replay() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->replay(context, request, response); }));
    }
    ~WithRawCallbackMethod_replay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status replay(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* replay(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_remote_node : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_remote_node() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->remote_node(context); }));
    }
    ~WithRawCallbackMethod_remote_node() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status remote_node(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::RemoteNodeMessage, ::thalamus_grpc::RemoteNodeMessage>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* remote_node(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_notification : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_notification() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->notification(context, request); }));
    }
    ~WithRawCallbackMethod_notification() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status notification(::grpc::ServerContext* /*context*/, const ::util_grpc::Empty* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* notification(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_node_request : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_node_request() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->node_request(context, request, response); }));
    }
    ~WithRawCallbackMethod_node_request() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status node_request(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* node_request(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_inject_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_inject_analog() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackClientStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, ::grpc::ByteBuffer* response) { return this->inject_analog(context, response); }));
    }
    ~WithRawCallbackMethod_inject_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_analog(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< ::thalamus_grpc::InjectAnalogRequest>* /*reader*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerReadReactor< ::grpc::ByteBuffer>* inject_analog(
      ::grpc::CallbackServerContext* /*context*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_get_modalities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_get_modalities() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->get_modalities(context, request, response); }));
    }
    ~WithRawCallbackMethod_get_modalities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status get_modalities(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* get_modalities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ping() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->ping(context); }));
    }
    ~WithRawCallbackMethod_ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ping(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::Ping>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* ping(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_inject_text : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_inject_text() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context) { return this->inject_text(context); }));
    }
    ~WithRawCallbackMethod_inject_text() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status inject_text(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::thalamus_grpc::Pong, ::thalamus_grpc::InjectTextRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* inject_text(
      ::grpc::CallbackServerContext* /*context*/)
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_type_name : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_type_name() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thalamus_grpc::StringMessage, ::thalamus_grpc::StringMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thalamus_grpc::StringMessage, ::thalamus_grpc::StringMessage>* streamer) {
                       return this->Streamedget_type_name(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_type_name() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_type_name(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::StringMessage* /*request*/, ::thalamus_grpc::StringMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_type_name(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thalamus_grpc::StringMessage,::thalamus_grpc::StringMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_recommended_channels : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_recommended_channels() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thalamus_grpc::NodeSelector, ::thalamus_grpc::StringListMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thalamus_grpc::NodeSelector, ::thalamus_grpc::StringListMessage>* streamer) {
                       return this->Streamedget_recommended_channels(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_recommended_channels() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_recommended_channels(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::StringListMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_recommended_channels(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thalamus_grpc::NodeSelector,::thalamus_grpc::StringListMessage>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_replay : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_replay() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thalamus_grpc::ReplayRequest, ::util_grpc::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thalamus_grpc::ReplayRequest, ::util_grpc::Empty>* streamer) {
                       return this->Streamedreplay(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_replay() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status replay(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ReplayRequest* /*request*/, ::util_grpc::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedreplay(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thalamus_grpc::ReplayRequest,::util_grpc::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_node_request : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_node_request() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thalamus_grpc::NodeRequest, ::thalamus_grpc::NodeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thalamus_grpc::NodeRequest, ::thalamus_grpc::NodeResponse>* streamer) {
                       return this->Streamednode_request(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_node_request() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status node_request(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeRequest* /*request*/, ::thalamus_grpc::NodeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamednode_request(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thalamus_grpc::NodeRequest,::thalamus_grpc::NodeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_get_modalities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_get_modalities() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::thalamus_grpc::NodeSelector, ::thalamus_grpc::ModalitiesMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::thalamus_grpc::NodeSelector, ::thalamus_grpc::ModalitiesMessage>* streamer) {
                       return this->Streamedget_modalities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_get_modalities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status get_modalities(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::thalamus_grpc::ModalitiesMessage* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedget_modalities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::thalamus_grpc::NodeSelector,::thalamus_grpc::ModalitiesMessage>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_get_type_name<WithStreamedUnaryMethod_get_recommended_channels<WithStreamedUnaryMethod_replay<WithStreamedUnaryMethod_node_request<WithStreamedUnaryMethod_get_modalities<Service > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_graph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_graph() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::thalamus_grpc::GraphRequest, ::thalamus_grpc::GraphResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::thalamus_grpc::GraphRequest, ::thalamus_grpc::GraphResponse>* streamer) {
                       return this->Streamedgraph(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_graph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status graph(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::GraphRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::GraphResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedgraph(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::thalamus_grpc::GraphRequest,::thalamus_grpc::GraphResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_analog : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_analog() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::thalamus_grpc::AnalogRequest, ::thalamus_grpc::AnalogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::thalamus_grpc::AnalogRequest, ::thalamus_grpc::AnalogResponse>* streamer) {
                       return this->Streamedanalog(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_analog() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status analog(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedanalog(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::thalamus_grpc::AnalogRequest,::thalamus_grpc::AnalogResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_spectrogram : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_spectrogram() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::thalamus_grpc::SpectrogramRequest, ::thalamus_grpc::SpectrogramResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::thalamus_grpc::SpectrogramRequest, ::thalamus_grpc::SpectrogramResponse>* streamer) {
                       return this->Streamedspectrogram(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_spectrogram() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status spectrogram(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::SpectrogramRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::SpectrogramResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedspectrogram(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::thalamus_grpc::SpectrogramRequest,::thalamus_grpc::SpectrogramResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_channel_info : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_channel_info() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::thalamus_grpc::AnalogRequest, ::thalamus_grpc::AnalogResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::thalamus_grpc::AnalogRequest, ::thalamus_grpc::AnalogResponse>* streamer) {
                       return this->Streamedchannel_info(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_channel_info() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status channel_info(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::AnalogRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::AnalogResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedchannel_info(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::thalamus_grpc::AnalogRequest,::thalamus_grpc::AnalogResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_xsens : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_xsens() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::thalamus_grpc::NodeSelector, ::thalamus_grpc::XsensResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::thalamus_grpc::NodeSelector, ::thalamus_grpc::XsensResponse>* streamer) {
                       return this->Streamedxsens(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_xsens() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status xsens(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::NodeSelector* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::XsensResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedxsens(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::thalamus_grpc::NodeSelector,::thalamus_grpc::XsensResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_image : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_image() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::thalamus_grpc::ImageRequest, ::thalamus_grpc::Image>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::thalamus_grpc::ImageRequest, ::thalamus_grpc::Image>* streamer) {
                       return this->Streamedimage(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_image() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status image(::grpc::ServerContext* /*context*/, const ::thalamus_grpc::ImageRequest* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Image>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamedimage(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::thalamus_grpc::ImageRequest,::thalamus_grpc::Image>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_notification : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_notification() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::util_grpc::Empty, ::thalamus_grpc::Notification>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::util_grpc::Empty, ::thalamus_grpc::Notification>* streamer) {
                       return this->Streamednotification(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_notification() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status notification(::grpc::ServerContext* /*context*/, const ::util_grpc::Empty* /*request*/, ::grpc::ServerWriter< ::thalamus_grpc::Notification>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status Streamednotification(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::util_grpc::Empty,::thalamus_grpc::Notification>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_graph<WithSplitStreamingMethod_analog<WithSplitStreamingMethod_spectrogram<WithSplitStreamingMethod_channel_info<WithSplitStreamingMethod_xsens<WithSplitStreamingMethod_image<WithSplitStreamingMethod_notification<Service > > > > > > > SplitStreamedService;
  typedef WithSplitStreamingMethod_graph<WithSplitStreamingMethod_analog<WithSplitStreamingMethod_spectrogram<WithSplitStreamingMethod_channel_info<WithSplitStreamingMethod_xsens<WithSplitStreamingMethod_image<WithStreamedUnaryMethod_get_type_name<WithStreamedUnaryMethod_get_recommended_channels<WithStreamedUnaryMethod_replay<WithSplitStreamingMethod_notification<WithStreamedUnaryMethod_node_request<WithStreamedUnaryMethod_get_modalities<Service > > > > > > > > > > > > StreamedService;
};

}  // namespace thalamus_grpc


#endif  // GRPC_thalamus_2eproto__INCLUDED
