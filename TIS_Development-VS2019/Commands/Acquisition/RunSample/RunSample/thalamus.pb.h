// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: thalamus.proto
// Protobuf C++ Version: 5.27.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_thalamus_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_thalamus_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5027002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "util.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_thalamus_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_thalamus_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_thalamus_2eproto;
namespace thalamus_grpc {
class AnalogRequest;
struct AnalogRequestDefaultTypeInternal;
extern AnalogRequestDefaultTypeInternal _AnalogRequest_default_instance_;
class AnalogResponse;
struct AnalogResponseDefaultTypeInternal;
extern AnalogResponseDefaultTypeInternal _AnalogResponse_default_instance_;
class ChannelId;
struct ChannelIdDefaultTypeInternal;
extern ChannelIdDefaultTypeInternal _ChannelId_default_instance_;
class EvalRequest;
struct EvalRequestDefaultTypeInternal;
extern EvalRequestDefaultTypeInternal _EvalRequest_default_instance_;
class EvalResponse;
struct EvalResponseDefaultTypeInternal;
extern EvalResponseDefaultTypeInternal _EvalResponse_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class GraphRequest;
struct GraphRequestDefaultTypeInternal;
extern GraphRequestDefaultTypeInternal _GraphRequest_default_instance_;
class GraphResponse;
struct GraphResponseDefaultTypeInternal;
extern GraphResponseDefaultTypeInternal _GraphResponse_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImageRequest;
struct ImageRequestDefaultTypeInternal;
extern ImageRequestDefaultTypeInternal _ImageRequest_default_instance_;
class InjectAnalogRequest;
struct InjectAnalogRequestDefaultTypeInternal;
extern InjectAnalogRequestDefaultTypeInternal _InjectAnalogRequest_default_instance_;
class InjectTextRequest;
struct InjectTextRequestDefaultTypeInternal;
extern InjectTextRequestDefaultTypeInternal _InjectTextRequest_default_instance_;
class ModalitiesMessage;
struct ModalitiesMessageDefaultTypeInternal;
extern ModalitiesMessageDefaultTypeInternal _ModalitiesMessage_default_instance_;
class NodeRequest;
struct NodeRequestDefaultTypeInternal;
extern NodeRequestDefaultTypeInternal _NodeRequest_default_instance_;
class NodeResponse;
struct NodeResponseDefaultTypeInternal;
extern NodeResponseDefaultTypeInternal _NodeResponse_default_instance_;
class NodeSelector;
struct NodeSelectorDefaultTypeInternal;
extern NodeSelectorDefaultTypeInternal _NodeSelector_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class ObservableChange;
struct ObservableChangeDefaultTypeInternal;
extern ObservableChangeDefaultTypeInternal _ObservableChange_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class RemoteNodeMessage;
struct RemoteNodeMessageDefaultTypeInternal;
extern RemoteNodeMessageDefaultTypeInternal _RemoteNodeMessage_default_instance_;
class ReplayRequest;
struct ReplayRequestDefaultTypeInternal;
extern ReplayRequestDefaultTypeInternal _ReplayRequest_default_instance_;
class Span;
struct SpanDefaultTypeInternal;
extern SpanDefaultTypeInternal _Span_default_instance_;
class Spectrogram;
struct SpectrogramDefaultTypeInternal;
extern SpectrogramDefaultTypeInternal _Spectrogram_default_instance_;
class SpectrogramRequest;
struct SpectrogramRequestDefaultTypeInternal;
extern SpectrogramRequestDefaultTypeInternal _SpectrogramRequest_default_instance_;
class SpectrogramResponse;
struct SpectrogramResponseDefaultTypeInternal;
extern SpectrogramResponseDefaultTypeInternal _SpectrogramResponse_default_instance_;
class StorageRecord;
struct StorageRecordDefaultTypeInternal;
extern StorageRecordDefaultTypeInternal _StorageRecord_default_instance_;
class StringListMessage;
struct StringListMessageDefaultTypeInternal;
extern StringListMessageDefaultTypeInternal _StringListMessage_default_instance_;
class StringMessage;
struct StringMessageDefaultTypeInternal;
extern StringMessageDefaultTypeInternal _StringMessage_default_instance_;
class Text;
struct TextDefaultTypeInternal;
extern TextDefaultTypeInternal _Text_default_instance_;
class XsensResponse;
struct XsensResponseDefaultTypeInternal;
extern XsensResponseDefaultTypeInternal _XsensResponse_default_instance_;
class XsensSegment;
struct XsensSegmentDefaultTypeInternal;
extern XsensSegmentDefaultTypeInternal _XsensSegment_default_instance_;
}  // namespace thalamus_grpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace thalamus_grpc {
enum Image_Format : int {
  Image_Format_Gray = 0,
  Image_Format_RGB = 1,
  Image_Format_YUYV422 = 2,
  Image_Format_YUV420P = 3,
  Image_Format_YUVJ420P = 4,
  Image_Format_Gray16 = 5,
  Image_Format_RGB16 = 6,
  Image_Format_Image_Format_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Image_Format_Image_Format_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Image_Format_IsValid(int value);
extern const uint32_t Image_Format_internal_data_[];
constexpr Image_Format Image_Format_Format_MIN = static_cast<Image_Format>(0);
constexpr Image_Format Image_Format_Format_MAX = static_cast<Image_Format>(6);
constexpr int Image_Format_Format_ARRAYSIZE = 6 + 1;
const ::google::protobuf::EnumDescriptor*
Image_Format_descriptor();
template <typename T>
const std::string& Image_Format_Name(T value) {
  static_assert(std::is_same<T, Image_Format>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Format_Name().");
  return Image_Format_Name(static_cast<Image_Format>(value));
}
template <>
inline const std::string& Image_Format_Name(Image_Format value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Image_Format_descriptor,
                                                 0, 6>(
      static_cast<int>(value));
}
inline bool Image_Format_Parse(absl::string_view name, Image_Format* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Image_Format>(
      Image_Format_descriptor(), name, value);
}
enum ObservableChange_Action : int {
  ObservableChange_Action_Set = 0,
  ObservableChange_Action_Delete = 1,
  ObservableChange_Action_ObservableChange_Action_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ObservableChange_Action_ObservableChange_Action_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ObservableChange_Action_IsValid(int value);
extern const uint32_t ObservableChange_Action_internal_data_[];
constexpr ObservableChange_Action ObservableChange_Action_Action_MIN = static_cast<ObservableChange_Action>(0);
constexpr ObservableChange_Action ObservableChange_Action_Action_MAX = static_cast<ObservableChange_Action>(1);
constexpr int ObservableChange_Action_Action_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
ObservableChange_Action_descriptor();
template <typename T>
const std::string& ObservableChange_Action_Name(T value) {
  static_assert(std::is_same<T, ObservableChange_Action>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Action_Name().");
  return ObservableChange_Action_Name(static_cast<ObservableChange_Action>(value));
}
template <>
inline const std::string& ObservableChange_Action_Name(ObservableChange_Action value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ObservableChange_Action_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool ObservableChange_Action_Parse(absl::string_view name, ObservableChange_Action* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObservableChange_Action>(
      ObservableChange_Action_descriptor(), name, value);
}
enum Notification_Type : int {
  Notification_Type_Error = 0,
  Notification_Type_Warning = 1,
  Notification_Type_Info = 2,
  Notification_Type_Notification_Type_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Notification_Type_Notification_Type_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Notification_Type_IsValid(int value);
extern const uint32_t Notification_Type_internal_data_[];
constexpr Notification_Type Notification_Type_Type_MIN = static_cast<Notification_Type>(0);
constexpr Notification_Type Notification_Type_Type_MAX = static_cast<Notification_Type>(2);
constexpr int Notification_Type_Type_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
Notification_Type_descriptor();
template <typename T>
const std::string& Notification_Type_Name(T value) {
  static_assert(std::is_same<T, Notification_Type>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Type_Name().");
  return Notification_Type_Name(static_cast<Notification_Type>(value));
}
template <>
inline const std::string& Notification_Type_Name(Notification_Type value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Notification_Type_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool Notification_Type_Parse(absl::string_view name, Notification_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Notification_Type>(
      Notification_Type_descriptor(), name, value);
}
enum Modalities : int {
  AnalogModality = 0,
  MocapModality = 1,
  ImageModality = 2,
  TextModality = 3,
  Modalities_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  Modalities_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool Modalities_IsValid(int value);
extern const uint32_t Modalities_internal_data_[];
constexpr Modalities Modalities_MIN = static_cast<Modalities>(0);
constexpr Modalities Modalities_MAX = static_cast<Modalities>(3);
constexpr int Modalities_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
Modalities_descriptor();
template <typename T>
const std::string& Modalities_Name(T value) {
  static_assert(std::is_same<T, Modalities>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to Modalities_Name().");
  return Modalities_Name(static_cast<Modalities>(value));
}
template <>
inline const std::string& Modalities_Name(Modalities value) {
  return ::google::protobuf::internal::NameOfDenseEnum<Modalities_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool Modalities_Parse(absl::string_view name, Modalities* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Modalities>(
      Modalities_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class XsensSegment final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.XsensSegment) */ {
 public:
  inline XsensSegment() : XsensSegment(nullptr) {}
  ~XsensSegment() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XsensSegment(
      ::google::protobuf::internal::ConstantInitialized);

  inline XsensSegment(const XsensSegment& from) : XsensSegment(nullptr, from) {}
  inline XsensSegment(XsensSegment&& from) noexcept
      : XsensSegment(nullptr, std::move(from)) {}
  inline XsensSegment& operator=(const XsensSegment& from) {
    CopyFrom(from);
    return *this;
  }
  inline XsensSegment& operator=(XsensSegment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XsensSegment& default_instance() {
    return *internal_default_instance();
  }
  static inline const XsensSegment* internal_default_instance() {
    return reinterpret_cast<const XsensSegment*>(
        &_XsensSegment_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(XsensSegment& a, XsensSegment& b) { a.Swap(&b); }
  inline void Swap(XsensSegment* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XsensSegment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XsensSegment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<XsensSegment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XsensSegment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XsensSegment& from) { XsensSegment::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XsensSegment* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.XsensSegment"; }

 protected:
  explicit XsensSegment(::google::protobuf::Arena* arena);
  XsensSegment(::google::protobuf::Arena* arena, const XsensSegment& from);
  XsensSegment(::google::protobuf::Arena* arena, XsensSegment&& from) noexcept
      : XsensSegment(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kZFieldNumber = 4,
    kQ0FieldNumber = 5,
    kQ1FieldNumber = 6,
    kQ2FieldNumber = 7,
    kQ3FieldNumber = 8,
    kFrameFieldNumber = 9,
    kTimeFieldNumber = 10,
  };
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // float x = 2;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // float y = 3;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // float z = 4;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // float q0 = 5;
  void clear_q0() ;
  float q0() const;
  void set_q0(float value);

  private:
  float _internal_q0() const;
  void _internal_set_q0(float value);

  public:
  // float q1 = 6;
  void clear_q1() ;
  float q1() const;
  void set_q1(float value);

  private:
  float _internal_q1() const;
  void _internal_set_q1(float value);

  public:
  // float q2 = 7;
  void clear_q2() ;
  float q2() const;
  void set_q2(float value);

  private:
  float _internal_q2() const;
  void _internal_set_q2(float value);

  public:
  // float q3 = 8;
  void clear_q3() ;
  float q3() const;
  void set_q3(float value);

  private:
  float _internal_q3() const;
  void _internal_set_q3(float value);

  public:
  // uint32 frame = 9;
  void clear_frame() ;
  ::uint32_t frame() const;
  void set_frame(::uint32_t value);

  private:
  ::uint32_t _internal_frame() const;
  void _internal_set_frame(::uint32_t value);

  public:
  // uint32 time = 10;
  void clear_time() ;
  ::uint32_t time() const;
  void set_time(::uint32_t value);

  private:
  ::uint32_t _internal_time() const;
  void _internal_set_time(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.XsensSegment)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_XsensSegment_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const XsensSegment& from_msg);
    ::uint32_t id_;
    float x_;
    float y_;
    float z_;
    float q0_;
    float q1_;
    float q2_;
    float q3_;
    ::uint32_t frame_;
    ::uint32_t time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Text final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Text) */ {
 public:
  inline Text() : Text(nullptr) {}
  ~Text() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Text(
      ::google::protobuf::internal::ConstantInitialized);

  inline Text(const Text& from) : Text(nullptr, from) {}
  inline Text(Text&& from) noexcept
      : Text(nullptr, std::move(from)) {}
  inline Text& operator=(const Text& from) {
    CopyFrom(from);
    return *this;
  }
  inline Text& operator=(Text&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Text& default_instance() {
    return *internal_default_instance();
  }
  static inline const Text* internal_default_instance() {
    return reinterpret_cast<const Text*>(
        &_Text_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(Text& a, Text& b) { a.Swap(&b); }
  inline void Swap(Text* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Text* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Text* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Text>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Text& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Text& from) { Text::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Text* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Text"; }

 protected:
  explicit Text(::google::protobuf::Arena* arena);
  Text(::google::protobuf::Arena* arena, const Text& from);
  Text(::google::protobuf::Arena* arena, Text&& from) noexcept
      : Text(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTextFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // string text = 1;
  void clear_text() ;
  const std::string& text() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_text(Arg_&& arg, Args_... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* value);

  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(
      const std::string& value);
  std::string* _internal_mutable_text();

  public:
  // uint64 time = 2;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Text)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      31, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Text_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Text& from_msg);
    ::google::protobuf::internal::ArenaStringPtr text_;
    ::uint64_t time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class StringMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.StringMessage) */ {
 public:
  inline StringMessage() : StringMessage(nullptr) {}
  ~StringMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StringMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline StringMessage(const StringMessage& from) : StringMessage(nullptr, from) {}
  inline StringMessage(StringMessage&& from) noexcept
      : StringMessage(nullptr, std::move(from)) {}
  inline StringMessage& operator=(const StringMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMessage& operator=(StringMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringMessage* internal_default_instance() {
    return reinterpret_cast<const StringMessage*>(
        &_StringMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(StringMessage& a, StringMessage& b) { a.Swap(&b); }
  inline void Swap(StringMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StringMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StringMessage& from) { StringMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.StringMessage"; }

 protected:
  explicit StringMessage(::google::protobuf::Arena* arena);
  StringMessage(::google::protobuf::Arena* arena, const StringMessage& from);
  StringMessage(::google::protobuf::Arena* arena, StringMessage&& from) noexcept
      : StringMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.StringMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StringMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StringMessage& from_msg);
    ::google::protobuf::internal::ArenaStringPtr value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class StringListMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.StringListMessage) */ {
 public:
  inline StringListMessage() : StringListMessage(nullptr) {}
  ~StringListMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StringListMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline StringListMessage(const StringListMessage& from) : StringListMessage(nullptr, from) {}
  inline StringListMessage(StringListMessage&& from) noexcept
      : StringListMessage(nullptr, std::move(from)) {}
  inline StringListMessage& operator=(const StringListMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringListMessage& operator=(StringListMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StringListMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StringListMessage* internal_default_instance() {
    return reinterpret_cast<const StringListMessage*>(
        &_StringListMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(StringListMessage& a, StringListMessage& b) { a.Swap(&b); }
  inline void Swap(StringListMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StringListMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StringListMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StringListMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StringListMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StringListMessage& from) { StringListMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StringListMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.StringListMessage"; }

 protected:
  explicit StringListMessage(::google::protobuf::Arena* arena);
  StringListMessage(::google::protobuf::Arena* arena, const StringListMessage& from);
  StringListMessage(::google::protobuf::Arena* arena, StringListMessage&& from) noexcept
      : StringListMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated string value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;

  public:
  void clear_value() ;
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, std::size_t size);
  void set_value(int index, absl::string_view value);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, std::size_t size);
  void add_value(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_value();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_value() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_value();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.StringListMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StringListMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StringListMessage& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Span final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Span) */ {
 public:
  inline Span() : Span(nullptr) {}
  ~Span() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Span(
      ::google::protobuf::internal::ConstantInitialized);

  inline Span(const Span& from) : Span(nullptr, from) {}
  inline Span(Span&& from) noexcept
      : Span(nullptr, std::move(from)) {}
  inline Span& operator=(const Span& from) {
    CopyFrom(from);
    return *this;
  }
  inline Span& operator=(Span&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Span& default_instance() {
    return *internal_default_instance();
  }
  static inline const Span* internal_default_instance() {
    return reinterpret_cast<const Span*>(
        &_Span_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(Span& a, Span& b) { a.Swap(&b); }
  inline void Swap(Span* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Span* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Span* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Span>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Span& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Span& from) { Span::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Span* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Span"; }

 protected:
  explicit Span(::google::protobuf::Arena* arena);
  Span(::google::protobuf::Arena* arena, const Span& from);
  Span(::google::protobuf::Arena* arena, Span&& from) noexcept
      : Span(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 3,
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // string name = 3;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // uint32 begin = 1;
  void clear_begin() ;
  ::uint32_t begin() const;
  void set_begin(::uint32_t value);

  private:
  ::uint32_t _internal_begin() const;
  void _internal_set_begin(::uint32_t value);

  public:
  // uint32 end = 2;
  void clear_end() ;
  ::uint32_t end() const;
  void set_end(::uint32_t value);

  private:
  ::uint32_t _internal_end() const;
  void _internal_set_end(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Span)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      31, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Span_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Span& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::uint32_t begin_;
    ::uint32_t end_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class ReplayRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.ReplayRequest) */ {
 public:
  inline ReplayRequest() : ReplayRequest(nullptr) {}
  ~ReplayRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ReplayRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ReplayRequest(const ReplayRequest& from) : ReplayRequest(nullptr, from) {}
  inline ReplayRequest(ReplayRequest&& from) noexcept
      : ReplayRequest(nullptr, std::move(from)) {}
  inline ReplayRequest& operator=(const ReplayRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplayRequest& operator=(ReplayRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplayRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplayRequest* internal_default_instance() {
    return reinterpret_cast<const ReplayRequest*>(
        &_ReplayRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(ReplayRequest& a, ReplayRequest& b) { a.Swap(&b); }
  inline void Swap(ReplayRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplayRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplayRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ReplayRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ReplayRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ReplayRequest& from) { ReplayRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ReplayRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.ReplayRequest"; }

 protected:
  explicit ReplayRequest(::google::protobuf::Arena* arena);
  ReplayRequest(::google::protobuf::Arena* arena, const ReplayRequest& from);
  ReplayRequest(::google::protobuf::Arena* arena, ReplayRequest&& from) noexcept
      : ReplayRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodesFieldNumber = 2,
    kFilenameFieldNumber = 1,
  };
  // repeated string nodes = 2;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;

  public:
  void clear_nodes() ;
  const std::string& nodes(int index) const;
  std::string* mutable_nodes(int index);
  void set_nodes(int index, const std::string& value);
  void set_nodes(int index, std::string&& value);
  void set_nodes(int index, const char* value);
  void set_nodes(int index, const char* value, std::size_t size);
  void set_nodes(int index, absl::string_view value);
  std::string* add_nodes();
  void add_nodes(const std::string& value);
  void add_nodes(std::string&& value);
  void add_nodes(const char* value);
  void add_nodes(const char* value, std::size_t size);
  void add_nodes(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& nodes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_nodes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_nodes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_nodes();

  public:
  // string filename = 1;
  void clear_filename() ;
  const std::string& filename() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filename(Arg_&& arg, Args_... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* value);

  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(
      const std::string& value);
  std::string* _internal_mutable_filename();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.ReplayRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ReplayRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ReplayRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> nodes_;
    ::google::protobuf::internal::ArenaStringPtr filename_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Pong final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  ~Pong() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pong(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pong(const Pong& from) : Pong(nullptr, from) {}
  inline Pong(Pong&& from) noexcept
      : Pong(nullptr, std::move(from)) {}
  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
        &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }
  inline void Swap(Pong* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Pong>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Pong& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Pong& from) { Pong::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Pong* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Pong"; }

 protected:
  explicit Pong(::google::protobuf::Arena* arena);
  Pong(::google::protobuf::Arena* arena, const Pong& from);
  Pong(::google::protobuf::Arena* arena, Pong&& from) noexcept
      : Pong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 3,
    kIdFieldNumber = 2,
  };
  // bytes payload = 3;
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint32 id = 2;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Pong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Pong_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pong& from_msg);
    ::google::protobuf::internal::ArenaStringPtr payload_;
    ::uint32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  ~Ping() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(
      ::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Ping& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Ping& from) { Ping::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Ping* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* arena);
  Ping(::google::protobuf::Arena* arena, const Ping& from);
  Ping(::google::protobuf::Arena* arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint32 id = 1;
  void clear_id() ;
  ::uint32_t id() const;
  void set_id(::uint32_t value);

  private:
  ::uint32_t _internal_id() const;
  void _internal_set_id(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Ping_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Ping& from_msg);
    ::google::protobuf::internal::ArenaStringPtr payload_;
    ::uint32_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class ObservableChange final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.ObservableChange) */ {
 public:
  inline ObservableChange() : ObservableChange(nullptr) {}
  ~ObservableChange() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ObservableChange(
      ::google::protobuf::internal::ConstantInitialized);

  inline ObservableChange(const ObservableChange& from) : ObservableChange(nullptr, from) {}
  inline ObservableChange(ObservableChange&& from) noexcept
      : ObservableChange(nullptr, std::move(from)) {}
  inline ObservableChange& operator=(const ObservableChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ObservableChange& operator=(ObservableChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ObservableChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const ObservableChange* internal_default_instance() {
    return reinterpret_cast<const ObservableChange*>(
        &_ObservableChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(ObservableChange& a, ObservableChange& b) { a.Swap(&b); }
  inline void Swap(ObservableChange* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ObservableChange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ObservableChange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ObservableChange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ObservableChange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ObservableChange& from) { ObservableChange::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ObservableChange* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.ObservableChange"; }

 protected:
  explicit ObservableChange(::google::protobuf::Arena* arena);
  ObservableChange(::google::protobuf::Arena* arena, const ObservableChange& from);
  ObservableChange(::google::protobuf::Arena* arena, ObservableChange&& from) noexcept
      : ObservableChange(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Action = ObservableChange_Action;
  static constexpr Action Set = ObservableChange_Action_Set;
  static constexpr Action Delete = ObservableChange_Action_Delete;
  static inline bool Action_IsValid(int value) {
    return ObservableChange_Action_IsValid(value);
  }
  static constexpr Action Action_MIN = ObservableChange_Action_Action_MIN;
  static constexpr Action Action_MAX = ObservableChange_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE = ObservableChange_Action_Action_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Action_descriptor() {
    return ObservableChange_Action_descriptor();
  }
  template <typename T>
  static inline const std::string& Action_Name(T value) {
    return ObservableChange_Action_Name(value);
  }
  static inline bool Action_Parse(absl::string_view name, Action* value) {
    return ObservableChange_Action_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kAddressFieldNumber = 1,
    kValueFieldNumber = 2,
    kIdFieldNumber = 4,
    kAcknowledgedFieldNumber = 5,
    kActionFieldNumber = 3,
  };
  // string address = 1;
  void clear_address() ;
  const std::string& address() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_address(Arg_&& arg, Args_... args);
  std::string* mutable_address();
  PROTOBUF_NODISCARD std::string* release_address();
  void set_allocated_address(std::string* value);

  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(
      const std::string& value);
  std::string* _internal_mutable_address();

  public:
  // string value = 2;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // uint64 id = 4;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // uint64 acknowledged = 5;
  void clear_acknowledged() ;
  ::uint64_t acknowledged() const;
  void set_acknowledged(::uint64_t value);

  private:
  ::uint64_t _internal_acknowledged() const;
  void _internal_set_acknowledged(::uint64_t value);

  public:
  // .thalamus_grpc.ObservableChange.Action action = 3;
  void clear_action() ;
  ::thalamus_grpc::ObservableChange_Action action() const;
  void set_action(::thalamus_grpc::ObservableChange_Action value);

  private:
  ::thalamus_grpc::ObservableChange_Action _internal_action() const;
  void _internal_set_action(::thalamus_grpc::ObservableChange_Action value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.ObservableChange)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      51, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ObservableChange_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ObservableChange& from_msg);
    ::google::protobuf::internal::ArenaStringPtr address_;
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::uint64_t id_;
    ::uint64_t acknowledged_;
    int action_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Notification final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Notification(
      ::google::protobuf::internal::ConstantInitialized);

  inline Notification(const Notification& from) : Notification(nullptr, from) {}
  inline Notification(Notification&& from) noexcept
      : Notification(nullptr, std::move(from)) {}
  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
        &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 31;
  friend void swap(Notification& a, Notification& b) { a.Swap(&b); }
  inline void Swap(Notification* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Notification>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Notification& from) { Notification::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Notification* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Notification"; }

 protected:
  explicit Notification(::google::protobuf::Arena* arena);
  Notification(::google::protobuf::Arena* arena, const Notification& from);
  Notification(::google::protobuf::Arena* arena, Notification&& from) noexcept
      : Notification(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Type = Notification_Type;
  static constexpr Type Error = Notification_Type_Error;
  static constexpr Type Warning = Notification_Type_Warning;
  static constexpr Type Info = Notification_Type_Info;
  static inline bool Type_IsValid(int value) {
    return Notification_Type_IsValid(value);
  }
  static constexpr Type Type_MIN = Notification_Type_Type_MIN;
  static constexpr Type Type_MAX = Notification_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE = Notification_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Type_descriptor() {
    return Notification_Type_descriptor();
  }
  template <typename T>
  static inline const std::string& Type_Name(T value) {
    return Notification_Type_Name(value);
  }
  static inline bool Type_Parse(absl::string_view name, Type* value) {
    return Notification_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kTitleFieldNumber = 2,
    kMessageFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // string title = 2;
  void clear_title() ;
  const std::string& title() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_title(Arg_&& arg, Args_... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* value);

  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(
      const std::string& value);
  std::string* _internal_mutable_title();

  public:
  // string message = 3;
  void clear_message() ;
  const std::string& message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message(Arg_&& arg, Args_... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* value);

  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(
      const std::string& value);
  std::string* _internal_mutable_message();

  public:
  // .thalamus_grpc.Notification.Type type = 1;
  void clear_type() ;
  ::thalamus_grpc::Notification_Type type() const;
  void set_type(::thalamus_grpc::Notification_Type value);

  private:
  ::thalamus_grpc::Notification_Type _internal_type() const;
  void _internal_set_type(::thalamus_grpc::Notification_Type value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Notification)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      47, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Notification_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Notification& from_msg);
    ::google::protobuf::internal::ArenaStringPtr title_;
    ::google::protobuf::internal::ArenaStringPtr message_;
    int type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class NodeSelector final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.NodeSelector) */ {
 public:
  inline NodeSelector() : NodeSelector(nullptr) {}
  ~NodeSelector() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeSelector(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeSelector(const NodeSelector& from) : NodeSelector(nullptr, from) {}
  inline NodeSelector(NodeSelector&& from) noexcept
      : NodeSelector(nullptr, std::move(from)) {}
  inline NodeSelector& operator=(const NodeSelector& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeSelector& operator=(NodeSelector&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeSelector& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeSelector* internal_default_instance() {
    return reinterpret_cast<const NodeSelector*>(
        &_NodeSelector_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(NodeSelector& a, NodeSelector& b) { a.Swap(&b); }
  inline void Swap(NodeSelector* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeSelector* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeSelector* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeSelector>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeSelector& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeSelector& from) { NodeSelector::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeSelector* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.NodeSelector"; }

 protected:
  explicit NodeSelector(::google::protobuf::Arena* arena);
  NodeSelector(::google::protobuf::Arena* arena, const NodeSelector& from);
  NodeSelector(::google::protobuf::Arena* arena, NodeSelector&& from) noexcept
      : NodeSelector(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string type = 2;
  void clear_type() ;
  const std::string& type() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type(Arg_&& arg, Args_... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* value);

  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(
      const std::string& value);
  std::string* _internal_mutable_type();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.NodeSelector)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      43, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NodeSelector_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeSelector& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class NodeResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.NodeResponse) */ {
 public:
  inline NodeResponse() : NodeResponse(nullptr) {}
  ~NodeResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeResponse(const NodeResponse& from) : NodeResponse(nullptr, from) {}
  inline NodeResponse(NodeResponse&& from) noexcept
      : NodeResponse(nullptr, std::move(from)) {}
  inline NodeResponse& operator=(const NodeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeResponse& operator=(NodeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeResponse*>(
        &_NodeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(NodeResponse& a, NodeResponse& b) { a.Swap(&b); }
  inline void Swap(NodeResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeResponse& from) { NodeResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.NodeResponse"; }

 protected:
  explicit NodeResponse(::google::protobuf::Arena* arena);
  NodeResponse(::google::protobuf::Arena* arena, const NodeResponse& from);
  NodeResponse(::google::protobuf::Arena* arena, NodeResponse&& from) noexcept
      : NodeResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kJsonFieldNumber = 1,
  };
  // string json = 1;
  void clear_json() ;
  const std::string& json() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_json(Arg_&& arg, Args_... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* value);

  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(
      const std::string& value);
  std::string* _internal_mutable_json();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.NodeResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      39, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NodeResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr json_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class NodeRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.NodeRequest) */ {
 public:
  inline NodeRequest() : NodeRequest(nullptr) {}
  ~NodeRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeRequest(const NodeRequest& from) : NodeRequest(nullptr, from) {}
  inline NodeRequest(NodeRequest&& from) noexcept
      : NodeRequest(nullptr, std::move(from)) {}
  inline NodeRequest& operator=(const NodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeRequest& operator=(NodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeRequest*>(
        &_NodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(NodeRequest& a, NodeRequest& b) { a.Swap(&b); }
  inline void Swap(NodeRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<NodeRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeRequest& from) { NodeRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NodeRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.NodeRequest"; }

 protected:
  explicit NodeRequest(::google::protobuf::Arena* arena);
  NodeRequest(::google::protobuf::Arena* arena, const NodeRequest& from);
  NodeRequest(::google::protobuf::Arena* arena, NodeRequest&& from) noexcept
      : NodeRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 1,
    kJsonFieldNumber = 2,
  };
  // string node = 1;
  void clear_node() ;
  const std::string& node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node(Arg_&& arg, Args_... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* value);

  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(
      const std::string& value);
  std::string* _internal_mutable_node();

  public:
  // string json = 2;
  void clear_json() ;
  const std::string& json() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_json(Arg_&& arg, Args_... args);
  std::string* mutable_json();
  PROTOBUF_NODISCARD std::string* release_json();
  void set_allocated_json(std::string* value);

  private:
  const std::string& _internal_json() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_json(
      const std::string& value);
  std::string* _internal_mutable_json();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.NodeRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      42, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_NodeRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr node_;
    ::google::protobuf::internal::ArenaStringPtr json_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class ModalitiesMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.ModalitiesMessage) */ {
 public:
  inline ModalitiesMessage() : ModalitiesMessage(nullptr) {}
  ~ModalitiesMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ModalitiesMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline ModalitiesMessage(const ModalitiesMessage& from) : ModalitiesMessage(nullptr, from) {}
  inline ModalitiesMessage(ModalitiesMessage&& from) noexcept
      : ModalitiesMessage(nullptr, std::move(from)) {}
  inline ModalitiesMessage& operator=(const ModalitiesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModalitiesMessage& operator=(ModalitiesMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ModalitiesMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModalitiesMessage* internal_default_instance() {
    return reinterpret_cast<const ModalitiesMessage*>(
        &_ModalitiesMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(ModalitiesMessage& a, ModalitiesMessage& b) { a.Swap(&b); }
  inline void Swap(ModalitiesMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModalitiesMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModalitiesMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ModalitiesMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ModalitiesMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ModalitiesMessage& from) { ModalitiesMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ModalitiesMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.ModalitiesMessage"; }

 protected:
  explicit ModalitiesMessage(::google::protobuf::Arena* arena);
  ModalitiesMessage(::google::protobuf::Arena* arena, const ModalitiesMessage& from);
  ModalitiesMessage(::google::protobuf::Arena* arena, ModalitiesMessage&& from) noexcept
      : ModalitiesMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValuesFieldNumber = 1,
  };
  // repeated .thalamus_grpc.Modalities values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;

  public:
  void clear_values() ;
  public:
  ::thalamus_grpc::Modalities values(int index) const;
  void set_values(int index, ::thalamus_grpc::Modalities value);
  void add_values(::thalamus_grpc::Modalities value);
  const ::google::protobuf::RepeatedField<int>& values() const;
  ::google::protobuf::RepeatedField<int>* mutable_values();

  private:
  const ::google::protobuf::RepeatedField<int>& _internal_values() const;
  ::google::protobuf::RepeatedField<int>* _internal_mutable_values();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.ModalitiesMessage)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ModalitiesMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ModalitiesMessage& from_msg);
    ::google::protobuf::RepeatedField<int> values_;
    mutable ::google::protobuf::internal::CachedSize _values_cached_byte_size_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Image final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Image(
      ::google::protobuf::internal::ConstantInitialized);

  inline Image(const Image& from) : Image(nullptr, from) {}
  inline Image(Image&& from) noexcept
      : Image(nullptr, std::move(from)) {}
  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
        &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(Image& a, Image& b) { a.Swap(&b); }
  inline void Swap(Image* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Image>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Image& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Image& from) { Image::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Image* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Image"; }

 protected:
  explicit Image(::google::protobuf::Arena* arena);
  Image(::google::protobuf::Arena* arena, const Image& from);
  Image(::google::protobuf::Arena* arena, Image&& from) noexcept
      : Image(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using Format = Image_Format;
  static constexpr Format Gray = Image_Format_Gray;
  static constexpr Format RGB = Image_Format_RGB;
  static constexpr Format YUYV422 = Image_Format_YUYV422;
  static constexpr Format YUV420P = Image_Format_YUV420P;
  static constexpr Format YUVJ420P = Image_Format_YUVJ420P;
  static constexpr Format Gray16 = Image_Format_Gray16;
  static constexpr Format RGB16 = Image_Format_RGB16;
  static inline bool Format_IsValid(int value) {
    return Image_Format_IsValid(value);
  }
  static constexpr Format Format_MIN = Image_Format_Format_MIN;
  static constexpr Format Format_MAX = Image_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE = Image_Format_Format_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* Format_descriptor() {
    return Image_Format_descriptor();
  }
  template <typename T>
  static inline const std::string& Format_Name(T value) {
    return Image_Format_Name(value);
  }
  static inline bool Format_Parse(absl::string_view name, Format* value) {
    return Image_Format_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kFrameIntervalFieldNumber = 5,
    kFormatFieldNumber = 4,
    kLastFieldNumber = 6,
    kBigendianFieldNumber = 7,
  };
  // repeated bytes data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  const std::string& data(int index) const;
  std::string* mutable_data(int index);
  void set_data(int index, const std::string& value);
  void set_data(int index, std::string&& value);
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, std::size_t size);
  void set_data(int index, absl::string_view value);
  std::string* add_data();
  void add_data(const std::string& value);
  void add_data(std::string&& value);
  void add_data(const char* value);
  void add_data(const void* value, std::size_t size);
  void add_data(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_data();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_data() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_data();

  public:
  // uint32 width = 2;
  void clear_width() ;
  ::uint32_t width() const;
  void set_width(::uint32_t value);

  private:
  ::uint32_t _internal_width() const;
  void _internal_set_width(::uint32_t value);

  public:
  // uint32 height = 3;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // uint64 frame_interval = 5;
  void clear_frame_interval() ;
  ::uint64_t frame_interval() const;
  void set_frame_interval(::uint64_t value);

  private:
  ::uint64_t _internal_frame_interval() const;
  void _internal_set_frame_interval(::uint64_t value);

  public:
  // .thalamus_grpc.Image.Format format = 4;
  void clear_format() ;
  ::thalamus_grpc::Image_Format format() const;
  void set_format(::thalamus_grpc::Image_Format value);

  private:
  ::thalamus_grpc::Image_Format _internal_format() const;
  void _internal_set_format(::thalamus_grpc::Image_Format value);

  public:
  // bool last = 6;
  void clear_last() ;
  bool last() const;
  void set_last(bool value);

  private:
  bool _internal_last() const;
  void _internal_set_last(bool value);

  public:
  // bool bigendian = 7;
  void clear_bigendian() ;
  bool bigendian() const;
  void set_bigendian(bool value);

  private:
  bool _internal_bigendian() const;
  void _internal_set_bigendian(bool value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Image)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Image_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Image& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> data_;
    ::uint32_t width_;
    ::uint32_t height_;
    ::uint64_t frame_interval_;
    int format_;
    bool last_;
    bool bigendian_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Event final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Event(
      ::google::protobuf::internal::ConstantInitialized);

  inline Event(const Event& from) : Event(nullptr, from) {}
  inline Event(Event&& from) noexcept
      : Event(nullptr, std::move(from)) {}
  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
        &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(Event& a, Event& b) { a.Swap(&b); }
  inline void Swap(Event* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Event* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Event>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Event& from) { Event::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Event* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Event"; }

 protected:
  explicit Event(::google::protobuf::Arena* arena);
  Event(::google::protobuf::Arena* arena, const Event& from);
  Event(::google::protobuf::Arena* arena, Event&& from) noexcept
      : Event(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPayloadFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // bytes payload = 1;
  void clear_payload() ;
  const std::string& payload() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_payload(Arg_&& arg, Args_... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* value);

  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(
      const std::string& value);
  std::string* _internal_mutable_payload();

  public:
  // uint64 time = 2;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Event)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Event_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Event& from_msg);
    ::google::protobuf::internal::ArenaStringPtr payload_;
    ::uint64_t time_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class EvalResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.EvalResponse) */ {
 public:
  inline EvalResponse() : EvalResponse(nullptr) {}
  ~EvalResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EvalResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline EvalResponse(const EvalResponse& from) : EvalResponse(nullptr, from) {}
  inline EvalResponse(EvalResponse&& from) noexcept
      : EvalResponse(nullptr, std::move(from)) {}
  inline EvalResponse& operator=(const EvalResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalResponse& operator=(EvalResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalResponse* internal_default_instance() {
    return reinterpret_cast<const EvalResponse*>(
        &_EvalResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(EvalResponse& a, EvalResponse& b) { a.Swap(&b); }
  inline void Swap(EvalResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EvalResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EvalResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EvalResponse& from) { EvalResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EvalResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.EvalResponse"; }

 protected:
  explicit EvalResponse(::google::protobuf::Arena* arena);
  EvalResponse(::google::protobuf::Arena* arena, const EvalResponse& from);
  EvalResponse(::google::protobuf::Arena* arena, EvalResponse&& from) noexcept
      : EvalResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValueFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string value = 1;
  void clear_value() ;
  const std::string& value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_value(Arg_&& arg, Args_... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);

  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(
      const std::string& value);
  std::string* _internal_mutable_value();

  public:
  // uint64 id = 2;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.EvalResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      40, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EvalResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EvalResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr value_;
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class EvalRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.EvalRequest) */ {
 public:
  inline EvalRequest() : EvalRequest(nullptr) {}
  ~EvalRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EvalRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline EvalRequest(const EvalRequest& from) : EvalRequest(nullptr, from) {}
  inline EvalRequest(EvalRequest&& from) noexcept
      : EvalRequest(nullptr, std::move(from)) {}
  inline EvalRequest& operator=(const EvalRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalRequest& operator=(EvalRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalRequest* internal_default_instance() {
    return reinterpret_cast<const EvalRequest*>(
        &_EvalRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(EvalRequest& a, EvalRequest& b) { a.Swap(&b); }
  inline void Swap(EvalRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<EvalRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EvalRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EvalRequest& from) { EvalRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EvalRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.EvalRequest"; }

 protected:
  explicit EvalRequest(::google::protobuf::Arena* arena);
  EvalRequest(::google::protobuf::Arena* arena, const EvalRequest& from);
  EvalRequest(::google::protobuf::Arena* arena, EvalRequest&& from) noexcept
      : EvalRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCodeFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // string code = 1;
  void clear_code() ;
  const std::string& code() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_code(Arg_&& arg, Args_... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* value);

  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(
      const std::string& value);
  std::string* _internal_mutable_code();

  public:
  // uint64 id = 2;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.EvalRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      38, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_EvalRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EvalRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr code_;
    ::uint64_t id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class ChannelId final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.ChannelId) */ {
 public:
  inline ChannelId() : ChannelId(nullptr) {}
  ~ChannelId() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChannelId(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChannelId(const ChannelId& from) : ChannelId(nullptr, from) {}
  inline ChannelId(ChannelId&& from) noexcept
      : ChannelId(nullptr, std::move(from)) {}
  inline ChannelId& operator=(const ChannelId& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelId& operator=(ChannelId&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelId& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelId* internal_default_instance() {
    return reinterpret_cast<const ChannelId*>(
        &_ChannelId_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(ChannelId& a, ChannelId& b) { a.Swap(&b); }
  inline void Swap(ChannelId* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelId* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelId* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ChannelId>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChannelId& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChannelId& from) { ChannelId::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChannelId* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.ChannelId"; }

 protected:
  explicit ChannelId(::google::protobuf::Arena* arena);
  ChannelId(::google::protobuf::Arena* arena, const ChannelId& from);
  ChannelId(::google::protobuf::Arena* arena, ChannelId&& from) noexcept
      : ChannelId(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // int32 index = 2;
  void clear_index() ;
  ::int32_t index() const;
  void set_index(::int32_t value);

  private:
  ::int32_t _internal_index() const;
  void _internal_set_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.ChannelId)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      36, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ChannelId_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChannelId& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::int32_t index_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class XsensResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.XsensResponse) */ {
 public:
  inline XsensResponse() : XsensResponse(nullptr) {}
  ~XsensResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR XsensResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline XsensResponse(const XsensResponse& from) : XsensResponse(nullptr, from) {}
  inline XsensResponse(XsensResponse&& from) noexcept
      : XsensResponse(nullptr, std::move(from)) {}
  inline XsensResponse& operator=(const XsensResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline XsensResponse& operator=(XsensResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const XsensResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const XsensResponse* internal_default_instance() {
    return reinterpret_cast<const XsensResponse*>(
        &_XsensResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(XsensResponse& a, XsensResponse& b) { a.Swap(&b); }
  inline void Swap(XsensResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XsensResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XsensResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<XsensResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const XsensResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const XsensResponse& from) { XsensResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(XsensResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.XsensResponse"; }

 protected:
  explicit XsensResponse(::google::protobuf::Arena* arena);
  XsensResponse(::google::protobuf::Arena* arena, const XsensResponse& from);
  XsensResponse(::google::protobuf::Arena* arena, XsensResponse&& from) noexcept
      : XsensResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSegmentsFieldNumber = 1,
    kPoseNameFieldNumber = 2,
  };
  // repeated .thalamus_grpc.XsensSegment segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;

  public:
  void clear_segments() ;
  ::thalamus_grpc::XsensSegment* mutable_segments(int index);
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>* mutable_segments();

  private:
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>& _internal_segments() const;
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>* _internal_mutable_segments();
  public:
  const ::thalamus_grpc::XsensSegment& segments(int index) const;
  ::thalamus_grpc::XsensSegment* add_segments();
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>& segments() const;
  // string pose_name = 2;
  void clear_pose_name() ;
  const std::string& pose_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pose_name(Arg_&& arg, Args_... args);
  std::string* mutable_pose_name();
  PROTOBUF_NODISCARD std::string* release_pose_name();
  void set_allocated_pose_name(std::string* value);

  private:
  const std::string& _internal_pose_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pose_name(
      const std::string& value);
  std::string* _internal_mutable_pose_name();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.XsensResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      45, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_XsensResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const XsensResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::thalamus_grpc::XsensSegment > segments_;
    ::google::protobuf::internal::ArenaStringPtr pose_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class SpectrogramRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.SpectrogramRequest) */ {
 public:
  inline SpectrogramRequest() : SpectrogramRequest(nullptr) {}
  ~SpectrogramRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpectrogramRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SpectrogramRequest(const SpectrogramRequest& from) : SpectrogramRequest(nullptr, from) {}
  inline SpectrogramRequest(SpectrogramRequest&& from) noexcept
      : SpectrogramRequest(nullptr, std::move(from)) {}
  inline SpectrogramRequest& operator=(const SpectrogramRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpectrogramRequest& operator=(SpectrogramRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpectrogramRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpectrogramRequest* internal_default_instance() {
    return reinterpret_cast<const SpectrogramRequest*>(
        &_SpectrogramRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(SpectrogramRequest& a, SpectrogramRequest& b) { a.Swap(&b); }
  inline void Swap(SpectrogramRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpectrogramRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpectrogramRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SpectrogramRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpectrogramRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpectrogramRequest& from) { SpectrogramRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpectrogramRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.SpectrogramRequest"; }

 protected:
  explicit SpectrogramRequest(::google::protobuf::Arena* arena);
  SpectrogramRequest(::google::protobuf::Arena* arena, const SpectrogramRequest& from);
  SpectrogramRequest(::google::protobuf::Arena* arena, SpectrogramRequest&& from) noexcept
      : SpectrogramRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannelsFieldNumber = 2,
    kNodeFieldNumber = 1,
    kWindowSFieldNumber = 3,
    kHopSFieldNumber = 4,
  };
  // repeated .thalamus_grpc.ChannelId channels = 2;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::thalamus_grpc::ChannelId* mutable_channels(int index);
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>* mutable_channels();

  private:
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>& _internal_channels() const;
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>* _internal_mutable_channels();
  public:
  const ::thalamus_grpc::ChannelId& channels(int index) const;
  ::thalamus_grpc::ChannelId* add_channels();
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>& channels() const;
  // .thalamus_grpc.NodeSelector node = 1;
  bool has_node() const;
  void clear_node() ;
  const ::thalamus_grpc::NodeSelector& node() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::NodeSelector* release_node();
  ::thalamus_grpc::NodeSelector* mutable_node();
  void set_allocated_node(::thalamus_grpc::NodeSelector* value);
  void unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value);
  ::thalamus_grpc::NodeSelector* unsafe_arena_release_node();

  private:
  const ::thalamus_grpc::NodeSelector& _internal_node() const;
  ::thalamus_grpc::NodeSelector* _internal_mutable_node();

  public:
  // double window_s = 3;
  void clear_window_s() ;
  double window_s() const;
  void set_window_s(double value);

  private:
  double _internal_window_s() const;
  void _internal_set_window_s(double value);

  public:
  // double hop_s = 4;
  void clear_hop_s() ;
  double hop_s() const;
  void set_hop_s(double value);

  private:
  double _internal_hop_s() const;
  void _internal_set_hop_s(double value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.SpectrogramRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SpectrogramRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SpectrogramRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::thalamus_grpc::ChannelId > channels_;
    ::thalamus_grpc::NodeSelector* node_;
    double window_s_;
    double hop_s_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class Spectrogram final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.Spectrogram) */ {
 public:
  inline Spectrogram() : Spectrogram(nullptr) {}
  ~Spectrogram() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Spectrogram(
      ::google::protobuf::internal::ConstantInitialized);

  inline Spectrogram(const Spectrogram& from) : Spectrogram(nullptr, from) {}
  inline Spectrogram(Spectrogram&& from) noexcept
      : Spectrogram(nullptr, std::move(from)) {}
  inline Spectrogram& operator=(const Spectrogram& from) {
    CopyFrom(from);
    return *this;
  }
  inline Spectrogram& operator=(Spectrogram&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Spectrogram& default_instance() {
    return *internal_default_instance();
  }
  static inline const Spectrogram* internal_default_instance() {
    return reinterpret_cast<const Spectrogram*>(
        &_Spectrogram_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Spectrogram& a, Spectrogram& b) { a.Swap(&b); }
  inline void Swap(Spectrogram* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Spectrogram* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Spectrogram* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Spectrogram>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Spectrogram& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Spectrogram& from) { Spectrogram::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Spectrogram* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.Spectrogram"; }

 protected:
  explicit Spectrogram(::google::protobuf::Arena* arena);
  Spectrogram(::google::protobuf::Arena* arena, const Spectrogram& from);
  Spectrogram(::google::protobuf::Arena* arena, Spectrogram&& from) noexcept
      : Spectrogram(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 2,
    kChannelFieldNumber = 1,
    kMaxFrequencyFieldNumber = 3,
  };
  // repeated double data = 2;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField<double>& data() const;
  ::google::protobuf::RepeatedField<double>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_data() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_data();

  public:
  // .thalamus_grpc.ChannelId channel = 1;
  bool has_channel() const;
  void clear_channel() ;
  const ::thalamus_grpc::ChannelId& channel() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::ChannelId* release_channel();
  ::thalamus_grpc::ChannelId* mutable_channel();
  void set_allocated_channel(::thalamus_grpc::ChannelId* value);
  void unsafe_arena_set_allocated_channel(::thalamus_grpc::ChannelId* value);
  ::thalamus_grpc::ChannelId* unsafe_arena_release_channel();

  private:
  const ::thalamus_grpc::ChannelId& _internal_channel() const;
  ::thalamus_grpc::ChannelId* _internal_mutable_channel();

  public:
  // double max_frequency = 3;
  void clear_max_frequency() ;
  double max_frequency() const;
  void set_max_frequency(double value);

  private:
  double _internal_max_frequency() const;
  void _internal_set_max_frequency(double value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.Spectrogram)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_Spectrogram_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Spectrogram& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<double> data_;
    ::thalamus_grpc::ChannelId* channel_;
    double max_frequency_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class InjectTextRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.InjectTextRequest) */ {
 public:
  inline InjectTextRequest() : InjectTextRequest(nullptr) {}
  ~InjectTextRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InjectTextRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline InjectTextRequest(const InjectTextRequest& from) : InjectTextRequest(nullptr, from) {}
  inline InjectTextRequest(InjectTextRequest&& from) noexcept
      : InjectTextRequest(nullptr, std::move(from)) {}
  inline InjectTextRequest& operator=(const InjectTextRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InjectTextRequest& operator=(InjectTextRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InjectTextRequest& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kNode = 1,
    kText = 2,
    BODY_NOT_SET = 0,
  };
  static inline const InjectTextRequest* internal_default_instance() {
    return reinterpret_cast<const InjectTextRequest*>(
        &_InjectTextRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(InjectTextRequest& a, InjectTextRequest& b) { a.Swap(&b); }
  inline void Swap(InjectTextRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InjectTextRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InjectTextRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InjectTextRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InjectTextRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InjectTextRequest& from) { InjectTextRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InjectTextRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.InjectTextRequest"; }

 protected:
  explicit InjectTextRequest(::google::protobuf::Arena* arena);
  InjectTextRequest(::google::protobuf::Arena* arena, const InjectTextRequest& from);
  InjectTextRequest(::google::protobuf::Arena* arena, InjectTextRequest&& from) noexcept
      : InjectTextRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 1,
    kTextFieldNumber = 2,
  };
  // string node = 1;
  bool has_node() const;
  void clear_node() ;
  const std::string& node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node(Arg_&& arg, Args_... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* value);

  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(
      const std::string& value);
  std::string* _internal_mutable_node();

  public:
  // .thalamus_grpc.Text text = 2;
  bool has_text() const;
  private:
  bool _internal_has_text() const;

  public:
  void clear_text() ;
  const ::thalamus_grpc::Text& text() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::Text* release_text();
  ::thalamus_grpc::Text* mutable_text();
  void set_allocated_text(::thalamus_grpc::Text* value);
  void unsafe_arena_set_allocated_text(::thalamus_grpc::Text* value);
  ::thalamus_grpc::Text* unsafe_arena_release_text();

  private:
  const ::thalamus_grpc::Text& _internal_text() const;
  ::thalamus_grpc::Text* _internal_mutable_text();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:thalamus_grpc.InjectTextRequest)
 private:
  class _Internal;
  void set_has_node();
  void set_has_text();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      44, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InjectTextRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InjectTextRequest& from_msg);
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr node_;
      ::thalamus_grpc::Text* text_;
    } body_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class ImageRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.ImageRequest) */ {
 public:
  inline ImageRequest() : ImageRequest(nullptr) {}
  ~ImageRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ImageRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ImageRequest(const ImageRequest& from) : ImageRequest(nullptr, from) {}
  inline ImageRequest(ImageRequest&& from) noexcept
      : ImageRequest(nullptr, std::move(from)) {}
  inline ImageRequest& operator=(const ImageRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImageRequest& operator=(ImageRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ImageRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ImageRequest* internal_default_instance() {
    return reinterpret_cast<const ImageRequest*>(
        &_ImageRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ImageRequest& a, ImageRequest& b) { a.Swap(&b); }
  inline void Swap(ImageRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImageRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ImageRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<ImageRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ImageRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ImageRequest& from) { ImageRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ImageRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.ImageRequest"; }

 protected:
  explicit ImageRequest(::google::protobuf::Arena* arena);
  ImageRequest(::google::protobuf::Arena* arena, const ImageRequest& from);
  ImageRequest(::google::protobuf::Arena* arena, ImageRequest&& from) noexcept
      : ImageRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 1,
    kFramerateFieldNumber = 2,
  };
  // .thalamus_grpc.NodeSelector node = 1;
  bool has_node() const;
  void clear_node() ;
  const ::thalamus_grpc::NodeSelector& node() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::NodeSelector* release_node();
  ::thalamus_grpc::NodeSelector* mutable_node();
  void set_allocated_node(::thalamus_grpc::NodeSelector* value);
  void unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value);
  ::thalamus_grpc::NodeSelector* unsafe_arena_release_node();

  private:
  const ::thalamus_grpc::NodeSelector& _internal_node() const;
  ::thalamus_grpc::NodeSelector* _internal_mutable_node();

  public:
  // double framerate = 2;
  void clear_framerate() ;
  double framerate() const;
  void set_framerate(double value);

  private:
  double _internal_framerate() const;
  void _internal_set_framerate(double value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.ImageRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ImageRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ImageRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::thalamus_grpc::NodeSelector* node_;
    double framerate_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class GraphResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.GraphResponse) */ {
 public:
  inline GraphResponse() : GraphResponse(nullptr) {}
  ~GraphResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GraphResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GraphResponse(const GraphResponse& from) : GraphResponse(nullptr, from) {}
  inline GraphResponse(GraphResponse&& from) noexcept
      : GraphResponse(nullptr, std::move(from)) {}
  inline GraphResponse& operator=(const GraphResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphResponse& operator=(GraphResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphResponse* internal_default_instance() {
    return reinterpret_cast<const GraphResponse*>(
        &_GraphResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(GraphResponse& a, GraphResponse& b) { a.Swap(&b); }
  inline void Swap(GraphResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GraphResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GraphResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GraphResponse& from) { GraphResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GraphResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.GraphResponse"; }

 protected:
  explicit GraphResponse(::google::protobuf::Arena* arena);
  GraphResponse(::google::protobuf::Arena* arena, const GraphResponse& from);
  GraphResponse(::google::protobuf::Arena* arena, GraphResponse&& from) noexcept
      : GraphResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBinsFieldNumber = 1,
    kSpansFieldNumber = 2,
    kChannelsChangedFieldNumber = 3,
  };
  // repeated double bins = 1;
  int bins_size() const;
  private:
  int _internal_bins_size() const;

  public:
  void clear_bins() ;
  double bins(int index) const;
  void set_bins(int index, double value);
  void add_bins(double value);
  const ::google::protobuf::RepeatedField<double>& bins() const;
  ::google::protobuf::RepeatedField<double>* mutable_bins();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_bins() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_bins();

  public:
  // repeated .thalamus_grpc.Span spans = 2;
  int spans_size() const;
  private:
  int _internal_spans_size() const;

  public:
  void clear_spans() ;
  ::thalamus_grpc::Span* mutable_spans(int index);
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>* mutable_spans();

  private:
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>& _internal_spans() const;
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>* _internal_mutable_spans();
  public:
  const ::thalamus_grpc::Span& spans(int index) const;
  ::thalamus_grpc::Span* add_spans();
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>& spans() const;
  // bool channels_changed = 3;
  void clear_channels_changed() ;
  bool channels_changed() const;
  void set_channels_changed(bool value);

  private:
  bool _internal_channels_changed() const;
  void _internal_set_channels_changed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.GraphResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GraphResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GraphResponse& from_msg);
    ::google::protobuf::RepeatedField<double> bins_;
    ::google::protobuf::RepeatedPtrField< ::thalamus_grpc::Span > spans_;
    bool channels_changed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class GraphRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.GraphRequest) */ {
 public:
  inline GraphRequest() : GraphRequest(nullptr) {}
  ~GraphRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GraphRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GraphRequest(const GraphRequest& from) : GraphRequest(nullptr, from) {}
  inline GraphRequest(GraphRequest&& from) noexcept
      : GraphRequest(nullptr, std::move(from)) {}
  inline GraphRequest& operator=(const GraphRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GraphRequest& operator=(GraphRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GraphRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GraphRequest* internal_default_instance() {
    return reinterpret_cast<const GraphRequest*>(
        &_GraphRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(GraphRequest& a, GraphRequest& b) { a.Swap(&b); }
  inline void Swap(GraphRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GraphRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GraphRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<GraphRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GraphRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GraphRequest& from) { GraphRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GraphRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.GraphRequest"; }

 protected:
  explicit GraphRequest(::google::protobuf::Arena* arena);
  GraphRequest(::google::protobuf::Arena* arena, const GraphRequest& from);
  GraphRequest(::google::protobuf::Arena* arena, GraphRequest&& from) noexcept
      : GraphRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannelsFieldNumber = 2,
    kChannelNamesFieldNumber = 4,
    kNodeFieldNumber = 1,
    kBinNsFieldNumber = 3,
  };
  // repeated int32 channels = 2;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& channels() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_channels();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_channels() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // repeated string channel_names = 4;
  int channel_names_size() const;
  private:
  int _internal_channel_names_size() const;

  public:
  void clear_channel_names() ;
  const std::string& channel_names(int index) const;
  std::string* mutable_channel_names(int index);
  void set_channel_names(int index, const std::string& value);
  void set_channel_names(int index, std::string&& value);
  void set_channel_names(int index, const char* value);
  void set_channel_names(int index, const char* value, std::size_t size);
  void set_channel_names(int index, absl::string_view value);
  std::string* add_channel_names();
  void add_channel_names(const std::string& value);
  void add_channel_names(std::string&& value);
  void add_channel_names(const char* value);
  void add_channel_names(const char* value, std::size_t size);
  void add_channel_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& channel_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_channel_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_channel_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_channel_names();

  public:
  // .thalamus_grpc.NodeSelector node = 1;
  bool has_node() const;
  void clear_node() ;
  const ::thalamus_grpc::NodeSelector& node() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::NodeSelector* release_node();
  ::thalamus_grpc::NodeSelector* mutable_node();
  void set_allocated_node(::thalamus_grpc::NodeSelector* value);
  void unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value);
  ::thalamus_grpc::NodeSelector* unsafe_arena_release_node();

  private:
  const ::thalamus_grpc::NodeSelector& _internal_node() const;
  ::thalamus_grpc::NodeSelector* _internal_mutable_node();

  public:
  // uint64 bin_ns = 3;
  void clear_bin_ns() ;
  ::uint64_t bin_ns() const;
  void set_bin_ns(::uint64_t value);

  private:
  ::uint64_t _internal_bin_ns() const;
  void _internal_set_bin_ns(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.GraphRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      48, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GraphRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GraphRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> channels_;
    mutable ::google::protobuf::internal::CachedSize _channels_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> channel_names_;
    ::thalamus_grpc::NodeSelector* node_;
    ::uint64_t bin_ns_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class AnalogResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.AnalogResponse) */ {
 public:
  inline AnalogResponse() : AnalogResponse(nullptr) {}
  ~AnalogResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AnalogResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline AnalogResponse(const AnalogResponse& from) : AnalogResponse(nullptr, from) {}
  inline AnalogResponse(AnalogResponse&& from) noexcept
      : AnalogResponse(nullptr, std::move(from)) {}
  inline AnalogResponse& operator=(const AnalogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogResponse& operator=(AnalogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalogResponse* internal_default_instance() {
    return reinterpret_cast<const AnalogResponse*>(
        &_AnalogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(AnalogResponse& a, AnalogResponse& b) { a.Swap(&b); }
  inline void Swap(AnalogResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalogResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalogResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AnalogResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalogResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AnalogResponse& from) { AnalogResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalogResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.AnalogResponse"; }

 protected:
  explicit AnalogResponse(::google::protobuf::Arena* arena);
  AnalogResponse(::google::protobuf::Arena* arena, const AnalogResponse& from);
  AnalogResponse(::google::protobuf::Arena* arena, AnalogResponse&& from) noexcept
      : AnalogResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
    kSpansFieldNumber = 2,
    kSampleIntervalsFieldNumber = 3,
    kChannelsChangedFieldNumber = 4,
  };
  // repeated double data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;

  public:
  void clear_data() ;
  double data(int index) const;
  void set_data(int index, double value);
  void add_data(double value);
  const ::google::protobuf::RepeatedField<double>& data() const;
  ::google::protobuf::RepeatedField<double>* mutable_data();

  private:
  const ::google::protobuf::RepeatedField<double>& _internal_data() const;
  ::google::protobuf::RepeatedField<double>* _internal_mutable_data();

  public:
  // repeated .thalamus_grpc.Span spans = 2;
  int spans_size() const;
  private:
  int _internal_spans_size() const;

  public:
  void clear_spans() ;
  ::thalamus_grpc::Span* mutable_spans(int index);
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>* mutable_spans();

  private:
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>& _internal_spans() const;
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>* _internal_mutable_spans();
  public:
  const ::thalamus_grpc::Span& spans(int index) const;
  ::thalamus_grpc::Span* add_spans();
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>& spans() const;
  // repeated uint64 sample_intervals = 3;
  int sample_intervals_size() const;
  private:
  int _internal_sample_intervals_size() const;

  public:
  void clear_sample_intervals() ;
  ::uint64_t sample_intervals(int index) const;
  void set_sample_intervals(int index, ::uint64_t value);
  void add_sample_intervals(::uint64_t value);
  const ::google::protobuf::RepeatedField<::uint64_t>& sample_intervals() const;
  ::google::protobuf::RepeatedField<::uint64_t>* mutable_sample_intervals();

  private:
  const ::google::protobuf::RepeatedField<::uint64_t>& _internal_sample_intervals() const;
  ::google::protobuf::RepeatedField<::uint64_t>* _internal_mutable_sample_intervals();

  public:
  // bool channels_changed = 4;
  void clear_channels_changed() ;
  bool channels_changed() const;
  void set_channels_changed(bool value);

  private:
  bool _internal_channels_changed() const;
  void _internal_set_channels_changed(bool value);

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.AnalogResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AnalogResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AnalogResponse& from_msg);
    ::google::protobuf::RepeatedField<double> data_;
    ::google::protobuf::RepeatedPtrField< ::thalamus_grpc::Span > spans_;
    ::google::protobuf::RepeatedField<::uint64_t> sample_intervals_;
    mutable ::google::protobuf::internal::CachedSize _sample_intervals_cached_byte_size_;
    bool channels_changed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class AnalogRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.AnalogRequest) */ {
 public:
  inline AnalogRequest() : AnalogRequest(nullptr) {}
  ~AnalogRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR AnalogRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline AnalogRequest(const AnalogRequest& from) : AnalogRequest(nullptr, from) {}
  inline AnalogRequest(AnalogRequest&& from) noexcept
      : AnalogRequest(nullptr, std::move(from)) {}
  inline AnalogRequest& operator=(const AnalogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnalogRequest& operator=(AnalogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AnalogRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AnalogRequest* internal_default_instance() {
    return reinterpret_cast<const AnalogRequest*>(
        &_AnalogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(AnalogRequest& a, AnalogRequest& b) { a.Swap(&b); }
  inline void Swap(AnalogRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnalogRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AnalogRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<AnalogRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AnalogRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const AnalogRequest& from) { AnalogRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AnalogRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.AnalogRequest"; }

 protected:
  explicit AnalogRequest(::google::protobuf::Arena* arena);
  AnalogRequest(::google::protobuf::Arena* arena, const AnalogRequest& from);
  AnalogRequest(::google::protobuf::Arena* arena, AnalogRequest&& from) noexcept
      : AnalogRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChannelsFieldNumber = 2,
    kChannelNamesFieldNumber = 3,
    kNodeFieldNumber = 1,
  };
  // repeated int32 channels = 2;
  int channels_size() const;
  private:
  int _internal_channels_size() const;

  public:
  void clear_channels() ;
  ::int32_t channels(int index) const;
  void set_channels(int index, ::int32_t value);
  void add_channels(::int32_t value);
  const ::google::protobuf::RepeatedField<::int32_t>& channels() const;
  ::google::protobuf::RepeatedField<::int32_t>* mutable_channels();

  private:
  const ::google::protobuf::RepeatedField<::int32_t>& _internal_channels() const;
  ::google::protobuf::RepeatedField<::int32_t>* _internal_mutable_channels();

  public:
  // repeated string channel_names = 3;
  int channel_names_size() const;
  private:
  int _internal_channel_names_size() const;

  public:
  void clear_channel_names() ;
  const std::string& channel_names(int index) const;
  std::string* mutable_channel_names(int index);
  void set_channel_names(int index, const std::string& value);
  void set_channel_names(int index, std::string&& value);
  void set_channel_names(int index, const char* value);
  void set_channel_names(int index, const char* value, std::size_t size);
  void set_channel_names(int index, absl::string_view value);
  std::string* add_channel_names();
  void add_channel_names(const std::string& value);
  void add_channel_names(std::string&& value);
  void add_channel_names(const char* value);
  void add_channel_names(const char* value, std::size_t size);
  void add_channel_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& channel_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_channel_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_channel_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_channel_names();

  public:
  // .thalamus_grpc.NodeSelector node = 1;
  bool has_node() const;
  void clear_node() ;
  const ::thalamus_grpc::NodeSelector& node() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::NodeSelector* release_node();
  ::thalamus_grpc::NodeSelector* mutable_node();
  void set_allocated_node(::thalamus_grpc::NodeSelector* value);
  void unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value);
  ::thalamus_grpc::NodeSelector* unsafe_arena_release_node();

  private:
  const ::thalamus_grpc::NodeSelector& _internal_node() const;
  ::thalamus_grpc::NodeSelector* _internal_mutable_node();

  public:
  // @@protoc_insertion_point(class_scope:thalamus_grpc.AnalogRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      49, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_AnalogRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const AnalogRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::int32_t> channels_;
    mutable ::google::protobuf::internal::CachedSize _channels_cached_byte_size_;
    ::google::protobuf::RepeatedPtrField<std::string> channel_names_;
    ::thalamus_grpc::NodeSelector* node_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class StorageRecord final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.StorageRecord) */ {
 public:
  inline StorageRecord() : StorageRecord(nullptr) {}
  ~StorageRecord() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StorageRecord(
      ::google::protobuf::internal::ConstantInitialized);

  inline StorageRecord(const StorageRecord& from) : StorageRecord(nullptr, from) {}
  inline StorageRecord(StorageRecord&& from) noexcept
      : StorageRecord(nullptr, std::move(from)) {}
  inline StorageRecord& operator=(const StorageRecord& from) {
    CopyFrom(from);
    return *this;
  }
  inline StorageRecord& operator=(StorageRecord&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StorageRecord& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kAnalog = 1,
    kXsens = 2,
    kEvent = 3,
    kImage = 6,
    kText = 7,
    BODY_NOT_SET = 0,
  };
  static inline const StorageRecord* internal_default_instance() {
    return reinterpret_cast<const StorageRecord*>(
        &_StorageRecord_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(StorageRecord& a, StorageRecord& b) { a.Swap(&b); }
  inline void Swap(StorageRecord* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StorageRecord* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StorageRecord* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<StorageRecord>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StorageRecord& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StorageRecord& from) { StorageRecord::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(StorageRecord* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.StorageRecord"; }

 protected:
  explicit StorageRecord(::google::protobuf::Arena* arena);
  StorageRecord(::google::protobuf::Arena* arena, const StorageRecord& from);
  StorageRecord(::google::protobuf::Arena* arena, StorageRecord&& from) noexcept
      : StorageRecord(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 5,
    kTimeFieldNumber = 4,
    kAnalogFieldNumber = 1,
    kXsensFieldNumber = 2,
    kEventFieldNumber = 3,
    kImageFieldNumber = 6,
    kTextFieldNumber = 7,
  };
  // string node = 5;
  void clear_node() ;
  const std::string& node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node(Arg_&& arg, Args_... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* value);

  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(
      const std::string& value);
  std::string* _internal_mutable_node();

  public:
  // uint64 time = 4;
  void clear_time() ;
  ::uint64_t time() const;
  void set_time(::uint64_t value);

  private:
  ::uint64_t _internal_time() const;
  void _internal_set_time(::uint64_t value);

  public:
  // .thalamus_grpc.AnalogResponse analog = 1;
  bool has_analog() const;
  private:
  bool _internal_has_analog() const;

  public:
  void clear_analog() ;
  const ::thalamus_grpc::AnalogResponse& analog() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::AnalogResponse* release_analog();
  ::thalamus_grpc::AnalogResponse* mutable_analog();
  void set_allocated_analog(::thalamus_grpc::AnalogResponse* value);
  void unsafe_arena_set_allocated_analog(::thalamus_grpc::AnalogResponse* value);
  ::thalamus_grpc::AnalogResponse* unsafe_arena_release_analog();

  private:
  const ::thalamus_grpc::AnalogResponse& _internal_analog() const;
  ::thalamus_grpc::AnalogResponse* _internal_mutable_analog();

  public:
  // .thalamus_grpc.XsensResponse xsens = 2;
  bool has_xsens() const;
  private:
  bool _internal_has_xsens() const;

  public:
  void clear_xsens() ;
  const ::thalamus_grpc::XsensResponse& xsens() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::XsensResponse* release_xsens();
  ::thalamus_grpc::XsensResponse* mutable_xsens();
  void set_allocated_xsens(::thalamus_grpc::XsensResponse* value);
  void unsafe_arena_set_allocated_xsens(::thalamus_grpc::XsensResponse* value);
  ::thalamus_grpc::XsensResponse* unsafe_arena_release_xsens();

  private:
  const ::thalamus_grpc::XsensResponse& _internal_xsens() const;
  ::thalamus_grpc::XsensResponse* _internal_mutable_xsens();

  public:
  // .thalamus_grpc.Event event = 3;
  bool has_event() const;
  private:
  bool _internal_has_event() const;

  public:
  void clear_event() ;
  const ::thalamus_grpc::Event& event() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::Event* release_event();
  ::thalamus_grpc::Event* mutable_event();
  void set_allocated_event(::thalamus_grpc::Event* value);
  void unsafe_arena_set_allocated_event(::thalamus_grpc::Event* value);
  ::thalamus_grpc::Event* unsafe_arena_release_event();

  private:
  const ::thalamus_grpc::Event& _internal_event() const;
  ::thalamus_grpc::Event* _internal_mutable_event();

  public:
  // .thalamus_grpc.Image image = 6;
  bool has_image() const;
  private:
  bool _internal_has_image() const;

  public:
  void clear_image() ;
  const ::thalamus_grpc::Image& image() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::Image* release_image();
  ::thalamus_grpc::Image* mutable_image();
  void set_allocated_image(::thalamus_grpc::Image* value);
  void unsafe_arena_set_allocated_image(::thalamus_grpc::Image* value);
  ::thalamus_grpc::Image* unsafe_arena_release_image();

  private:
  const ::thalamus_grpc::Image& _internal_image() const;
  ::thalamus_grpc::Image* _internal_mutable_image();

  public:
  // .thalamus_grpc.Text text = 7;
  bool has_text() const;
  private:
  bool _internal_has_text() const;

  public:
  void clear_text() ;
  const ::thalamus_grpc::Text& text() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::Text* release_text();
  ::thalamus_grpc::Text* mutable_text();
  void set_allocated_text(::thalamus_grpc::Text* value);
  void unsafe_arena_set_allocated_text(::thalamus_grpc::Text* value);
  ::thalamus_grpc::Text* unsafe_arena_release_text();

  private:
  const ::thalamus_grpc::Text& _internal_text() const;
  ::thalamus_grpc::Text* _internal_mutable_text();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:thalamus_grpc.StorageRecord)
 private:
  class _Internal;
  void set_has_analog();
  void set_has_xsens();
  void set_has_event();
  void set_has_image();
  void set_has_text();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 7, 5,
      40, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_StorageRecord_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StorageRecord& from_msg);
    ::google::protobuf::internal::ArenaStringPtr node_;
    ::uint64_t time_;
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::thalamus_grpc::AnalogResponse* analog_;
      ::thalamus_grpc::XsensResponse* xsens_;
      ::thalamus_grpc::Event* event_;
      ::thalamus_grpc::Image* image_;
      ::thalamus_grpc::Text* text_;
    } body_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class SpectrogramResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.SpectrogramResponse) */ {
 public:
  inline SpectrogramResponse() : SpectrogramResponse(nullptr) {}
  ~SpectrogramResponse() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SpectrogramResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SpectrogramResponse(const SpectrogramResponse& from) : SpectrogramResponse(nullptr, from) {}
  inline SpectrogramResponse(SpectrogramResponse&& from) noexcept
      : SpectrogramResponse(nullptr, std::move(from)) {}
  inline SpectrogramResponse& operator=(const SpectrogramResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpectrogramResponse& operator=(SpectrogramResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpectrogramResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpectrogramResponse* internal_default_instance() {
    return reinterpret_cast<const SpectrogramResponse*>(
        &_SpectrogramResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SpectrogramResponse& a, SpectrogramResponse& b) { a.Swap(&b); }
  inline void Swap(SpectrogramResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpectrogramResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpectrogramResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<SpectrogramResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SpectrogramResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SpectrogramResponse& from) { SpectrogramResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SpectrogramResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.SpectrogramResponse"; }

 protected:
  explicit SpectrogramResponse(::google::protobuf::Arena* arena);
  SpectrogramResponse(::google::protobuf::Arena* arena, const SpectrogramResponse& from);
  SpectrogramResponse(::google::protobuf::Arena* arena, SpectrogramResponse&& from) noexcept
      : SpectrogramResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSpectrogramsFieldNumber = 1,
  };
  // repeated .thalamus_grpc.Spectrogram spectrograms = 1;
  int spectrograms_size() const;
  private:
  int _internal_spectrograms_size() const;

  public:
  void clear_spectrograms() ;
  ::thalamus_grpc::Spectrogram* mutable_spectrograms(int index);
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>* mutable_spectrograms();

  private:
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>& _internal_spectrograms() const;
  ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>* _internal_mutable_spectrograms();
  public:
  const ::thalamus_grpc::Spectrogram& spectrograms(int index) const;
  ::thalamus_grpc::Spectrogram* add_spectrograms();
  const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>& spectrograms() const;
  // @@protoc_insertion_point(class_scope:thalamus_grpc.SpectrogramResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SpectrogramResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SpectrogramResponse& from_msg);
    ::google::protobuf::RepeatedPtrField< ::thalamus_grpc::Spectrogram > spectrograms_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class RemoteNodeMessage final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.RemoteNodeMessage) */ {
 public:
  inline RemoteNodeMessage() : RemoteNodeMessage(nullptr) {}
  ~RemoteNodeMessage() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RemoteNodeMessage(
      ::google::protobuf::internal::ConstantInitialized);

  inline RemoteNodeMessage(const RemoteNodeMessage& from) : RemoteNodeMessage(nullptr, from) {}
  inline RemoteNodeMessage(RemoteNodeMessage&& from) noexcept
      : RemoteNodeMessage(nullptr, std::move(from)) {}
  inline RemoteNodeMessage& operator=(const RemoteNodeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteNodeMessage& operator=(RemoteNodeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteNodeMessage& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kRequest = 1,
    kData = 2,
    kPing = 3,
    kPong = 4,
    BODY_NOT_SET = 0,
  };
  static inline const RemoteNodeMessage* internal_default_instance() {
    return reinterpret_cast<const RemoteNodeMessage*>(
        &_RemoteNodeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(RemoteNodeMessage& a, RemoteNodeMessage& b) { a.Swap(&b); }
  inline void Swap(RemoteNodeMessage* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteNodeMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoteNodeMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<RemoteNodeMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RemoteNodeMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RemoteNodeMessage& from) { RemoteNodeMessage::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RemoteNodeMessage* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.RemoteNodeMessage"; }

 protected:
  explicit RemoteNodeMessage(::google::protobuf::Arena* arena);
  RemoteNodeMessage(::google::protobuf::Arena* arena, const RemoteNodeMessage& from);
  RemoteNodeMessage(::google::protobuf::Arena* arena, RemoteNodeMessage&& from) noexcept
      : RemoteNodeMessage(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRequestFieldNumber = 1,
    kDataFieldNumber = 2,
    kPingFieldNumber = 3,
    kPongFieldNumber = 4,
  };
  // .thalamus_grpc.AnalogRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;

  public:
  void clear_request() ;
  const ::thalamus_grpc::AnalogRequest& request() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::AnalogRequest* release_request();
  ::thalamus_grpc::AnalogRequest* mutable_request();
  void set_allocated_request(::thalamus_grpc::AnalogRequest* value);
  void unsafe_arena_set_allocated_request(::thalamus_grpc::AnalogRequest* value);
  ::thalamus_grpc::AnalogRequest* unsafe_arena_release_request();

  private:
  const ::thalamus_grpc::AnalogRequest& _internal_request() const;
  ::thalamus_grpc::AnalogRequest* _internal_mutable_request();

  public:
  // .thalamus_grpc.AnalogResponse data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;

  public:
  void clear_data() ;
  const ::thalamus_grpc::AnalogResponse& data() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::AnalogResponse* release_data();
  ::thalamus_grpc::AnalogResponse* mutable_data();
  void set_allocated_data(::thalamus_grpc::AnalogResponse* value);
  void unsafe_arena_set_allocated_data(::thalamus_grpc::AnalogResponse* value);
  ::thalamus_grpc::AnalogResponse* unsafe_arena_release_data();

  private:
  const ::thalamus_grpc::AnalogResponse& _internal_data() const;
  ::thalamus_grpc::AnalogResponse* _internal_mutable_data();

  public:
  // .thalamus_grpc.Ping ping = 3;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;

  public:
  void clear_ping() ;
  const ::thalamus_grpc::Ping& ping() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::Ping* release_ping();
  ::thalamus_grpc::Ping* mutable_ping();
  void set_allocated_ping(::thalamus_grpc::Ping* value);
  void unsafe_arena_set_allocated_ping(::thalamus_grpc::Ping* value);
  ::thalamus_grpc::Ping* unsafe_arena_release_ping();

  private:
  const ::thalamus_grpc::Ping& _internal_ping() const;
  ::thalamus_grpc::Ping* _internal_mutable_ping();

  public:
  // .thalamus_grpc.Pong pong = 4;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;

  public:
  void clear_pong() ;
  const ::thalamus_grpc::Pong& pong() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::Pong* release_pong();
  ::thalamus_grpc::Pong* mutable_pong();
  void set_allocated_pong(::thalamus_grpc::Pong* value);
  void unsafe_arena_set_allocated_pong(::thalamus_grpc::Pong* value);
  ::thalamus_grpc::Pong* unsafe_arena_release_pong();

  private:
  const ::thalamus_grpc::Pong& _internal_pong() const;
  ::thalamus_grpc::Pong* _internal_mutable_pong();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:thalamus_grpc.RemoteNodeMessage)
 private:
  class _Internal;
  void set_has_request();
  void set_has_data();
  void set_has_ping();
  void set_has_pong();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 4, 4,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_RemoteNodeMessage_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RemoteNodeMessage& from_msg);
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::thalamus_grpc::AnalogRequest* request_;
      ::thalamus_grpc::AnalogResponse* data_;
      ::thalamus_grpc::Ping* ping_;
      ::thalamus_grpc::Pong* pong_;
    } body_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};
// -------------------------------------------------------------------

class InjectAnalogRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:thalamus_grpc.InjectAnalogRequest) */ {
 public:
  inline InjectAnalogRequest() : InjectAnalogRequest(nullptr) {}
  ~InjectAnalogRequest() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InjectAnalogRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline InjectAnalogRequest(const InjectAnalogRequest& from) : InjectAnalogRequest(nullptr, from) {}
  inline InjectAnalogRequest(InjectAnalogRequest&& from) noexcept
      : InjectAnalogRequest(nullptr, std::move(from)) {}
  inline InjectAnalogRequest& operator=(const InjectAnalogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InjectAnalogRequest& operator=(InjectAnalogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InjectAnalogRequest& default_instance() {
    return *internal_default_instance();
  }
  enum BodyCase {
    kNode = 1,
    kSignal = 2,
    BODY_NOT_SET = 0,
  };
  static inline const InjectAnalogRequest* internal_default_instance() {
    return reinterpret_cast<const InjectAnalogRequest*>(
        &_InjectAnalogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(InjectAnalogRequest& a, InjectAnalogRequest& b) { a.Swap(&b); }
  inline void Swap(InjectAnalogRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InjectAnalogRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InjectAnalogRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<InjectAnalogRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InjectAnalogRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InjectAnalogRequest& from) { InjectAnalogRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InjectAnalogRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "thalamus_grpc.InjectAnalogRequest"; }

 protected:
  explicit InjectAnalogRequest(::google::protobuf::Arena* arena);
  InjectAnalogRequest(::google::protobuf::Arena* arena, const InjectAnalogRequest& from);
  InjectAnalogRequest(::google::protobuf::Arena* arena, InjectAnalogRequest&& from) noexcept
      : InjectAnalogRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeFieldNumber = 1,
    kSignalFieldNumber = 2,
  };
  // string node = 1;
  bool has_node() const;
  void clear_node() ;
  const std::string& node() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node(Arg_&& arg, Args_... args);
  std::string* mutable_node();
  PROTOBUF_NODISCARD std::string* release_node();
  void set_allocated_node(std::string* value);

  private:
  const std::string& _internal_node() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node(
      const std::string& value);
  std::string* _internal_mutable_node();

  public:
  // .thalamus_grpc.AnalogResponse signal = 2;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;

  public:
  void clear_signal() ;
  const ::thalamus_grpc::AnalogResponse& signal() const;
  PROTOBUF_NODISCARD ::thalamus_grpc::AnalogResponse* release_signal();
  ::thalamus_grpc::AnalogResponse* mutable_signal();
  void set_allocated_signal(::thalamus_grpc::AnalogResponse* value);
  void unsafe_arena_set_allocated_signal(::thalamus_grpc::AnalogResponse* value);
  ::thalamus_grpc::AnalogResponse* unsafe_arena_release_signal();

  private:
  const ::thalamus_grpc::AnalogResponse& _internal_signal() const;
  ::thalamus_grpc::AnalogResponse* _internal_mutable_signal();

  public:
  void clear_body();
  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:thalamus_grpc.InjectAnalogRequest)
 private:
  class _Internal;
  void set_has_node();
  void set_has_signal();
  inline bool has_body() const;
  inline void clear_has_body();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      46, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InjectAnalogRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InjectAnalogRequest& from_msg);
    union BodyUnion {
      constexpr BodyUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr node_;
      ::thalamus_grpc::AnalogResponse* signal_;
    } body_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_thalamus_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ChannelId

// string name = 1;
inline void ChannelId::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& ChannelId::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ChannelId.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChannelId::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.ChannelId.name)
}
inline std::string* ChannelId::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.ChannelId.name)
  return _s;
}
inline const std::string& ChannelId::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void ChannelId::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* ChannelId::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* ChannelId::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.ChannelId.name)
  return _impl_.name_.Release();
}
inline void ChannelId::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.ChannelId.name)
}

// int32 index = 2;
inline void ChannelId::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = 0;
}
inline ::int32_t ChannelId::index() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ChannelId.index)
  return _internal_index();
}
inline void ChannelId::set_index(::int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ChannelId.index)
}
inline ::int32_t ChannelId::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void ChannelId::_internal_set_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// Spectrogram

// .thalamus_grpc.ChannelId channel = 1;
inline bool Spectrogram::has_channel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channel_ != nullptr);
  return value;
}
inline void Spectrogram::clear_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channel_ != nullptr) _impl_.channel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thalamus_grpc::ChannelId& Spectrogram::_internal_channel() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::thalamus_grpc::ChannelId* p = _impl_.channel_;
  return p != nullptr ? *p : reinterpret_cast<const ::thalamus_grpc::ChannelId&>(::thalamus_grpc::_ChannelId_default_instance_);
}
inline const ::thalamus_grpc::ChannelId& Spectrogram::channel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Spectrogram.channel)
  return _internal_channel();
}
inline void Spectrogram::unsafe_arena_set_allocated_channel(::thalamus_grpc::ChannelId* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channel_);
  }
  _impl_.channel_ = reinterpret_cast<::thalamus_grpc::ChannelId*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.Spectrogram.channel)
}
inline ::thalamus_grpc::ChannelId* Spectrogram::release_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::ChannelId* released = _impl_.channel_;
  _impl_.channel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thalamus_grpc::ChannelId* Spectrogram::unsafe_arena_release_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Spectrogram.channel)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::ChannelId* temp = _impl_.channel_;
  _impl_.channel_ = nullptr;
  return temp;
}
inline ::thalamus_grpc::ChannelId* Spectrogram::_internal_mutable_channel() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channel_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::ChannelId>(GetArena());
    _impl_.channel_ = reinterpret_cast<::thalamus_grpc::ChannelId*>(p);
  }
  return _impl_.channel_;
}
inline ::thalamus_grpc::ChannelId* Spectrogram::mutable_channel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::thalamus_grpc::ChannelId* _msg = _internal_mutable_channel();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Spectrogram.channel)
  return _msg;
}
inline void Spectrogram::set_allocated_channel(::thalamus_grpc::ChannelId* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.channel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.channel_ = reinterpret_cast<::thalamus_grpc::ChannelId*>(value);
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Spectrogram.channel)
}

// repeated double data = 2;
inline int Spectrogram::_internal_data_size() const {
  return _internal_data().size();
}
inline int Spectrogram::data_size() const {
  return _internal_data_size();
}
inline void Spectrogram::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline double Spectrogram::data(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Spectrogram.data)
  return _internal_data().Get(index);
}
inline void Spectrogram::set_data(int index, double value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Spectrogram.data)
}
inline void Spectrogram::add_data(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.Spectrogram.data)
}
inline const ::google::protobuf::RepeatedField<double>& Spectrogram::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.Spectrogram.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<double>* Spectrogram::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.Spectrogram.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<double>&
Spectrogram::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<double>* Spectrogram::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// double max_frequency = 3;
inline void Spectrogram::clear_max_frequency() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_frequency_ = 0;
}
inline double Spectrogram::max_frequency() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Spectrogram.max_frequency)
  return _internal_max_frequency();
}
inline void Spectrogram::set_max_frequency(double value) {
  _internal_set_max_frequency(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Spectrogram.max_frequency)
}
inline double Spectrogram::_internal_max_frequency() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.max_frequency_;
}
inline void Spectrogram::_internal_set_max_frequency(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.max_frequency_ = value;
}

// -------------------------------------------------------------------

// SpectrogramRequest

// .thalamus_grpc.NodeSelector node = 1;
inline bool SpectrogramRequest::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline void SpectrogramRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ != nullptr) _impl_.node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thalamus_grpc::NodeSelector& SpectrogramRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::thalamus_grpc::NodeSelector* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::thalamus_grpc::NodeSelector&>(::thalamus_grpc::_NodeSelector_default_instance_);
}
inline const ::thalamus_grpc::NodeSelector& SpectrogramRequest::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.SpectrogramRequest.node)
  return _internal_node();
}
inline void SpectrogramRequest::unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.SpectrogramRequest.node)
}
inline ::thalamus_grpc::NodeSelector* SpectrogramRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* released = _impl_.node_;
  _impl_.node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thalamus_grpc::NodeSelector* SpectrogramRequest::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.SpectrogramRequest.node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::thalamus_grpc::NodeSelector* SpectrogramRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::NodeSelector>(GetArena());
    _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(p);
  }
  return _impl_.node_;
}
inline ::thalamus_grpc::NodeSelector* SpectrogramRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::thalamus_grpc::NodeSelector* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.SpectrogramRequest.node)
  return _msg;
}
inline void SpectrogramRequest::set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.SpectrogramRequest.node)
}

// repeated .thalamus_grpc.ChannelId channels = 2;
inline int SpectrogramRequest::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int SpectrogramRequest::channels_size() const {
  return _internal_channels_size();
}
inline void SpectrogramRequest::clear_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_.Clear();
}
inline ::thalamus_grpc::ChannelId* SpectrogramRequest::mutable_channels(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.SpectrogramRequest.channels)
  return _internal_mutable_channels()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>* SpectrogramRequest::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.SpectrogramRequest.channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channels();
}
inline const ::thalamus_grpc::ChannelId& SpectrogramRequest::channels(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.SpectrogramRequest.channels)
  return _internal_channels().Get(index);
}
inline ::thalamus_grpc::ChannelId* SpectrogramRequest::add_channels() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::thalamus_grpc::ChannelId* _add = _internal_mutable_channels()->Add();
  // @@protoc_insertion_point(field_add:thalamus_grpc.SpectrogramRequest.channels)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>& SpectrogramRequest::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.SpectrogramRequest.channels)
  return _internal_channels();
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>&
SpectrogramRequest::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::ChannelId>*
SpectrogramRequest::_internal_mutable_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channels_;
}

// double window_s = 3;
inline void SpectrogramRequest::clear_window_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.window_s_ = 0;
}
inline double SpectrogramRequest::window_s() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.SpectrogramRequest.window_s)
  return _internal_window_s();
}
inline void SpectrogramRequest::set_window_s(double value) {
  _internal_set_window_s(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.SpectrogramRequest.window_s)
}
inline double SpectrogramRequest::_internal_window_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.window_s_;
}
inline void SpectrogramRequest::_internal_set_window_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.window_s_ = value;
}

// double hop_s = 4;
inline void SpectrogramRequest::clear_hop_s() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_s_ = 0;
}
inline double SpectrogramRequest::hop_s() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.SpectrogramRequest.hop_s)
  return _internal_hop_s();
}
inline void SpectrogramRequest::set_hop_s(double value) {
  _internal_set_hop_s(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.SpectrogramRequest.hop_s)
}
inline double SpectrogramRequest::_internal_hop_s() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hop_s_;
}
inline void SpectrogramRequest::_internal_set_hop_s(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hop_s_ = value;
}

// -------------------------------------------------------------------

// SpectrogramResponse

// repeated .thalamus_grpc.Spectrogram spectrograms = 1;
inline int SpectrogramResponse::_internal_spectrograms_size() const {
  return _internal_spectrograms().size();
}
inline int SpectrogramResponse::spectrograms_size() const {
  return _internal_spectrograms_size();
}
inline void SpectrogramResponse::clear_spectrograms() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spectrograms_.Clear();
}
inline ::thalamus_grpc::Spectrogram* SpectrogramResponse::mutable_spectrograms(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.SpectrogramResponse.spectrograms)
  return _internal_mutable_spectrograms()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>* SpectrogramResponse::mutable_spectrograms()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.SpectrogramResponse.spectrograms)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spectrograms();
}
inline const ::thalamus_grpc::Spectrogram& SpectrogramResponse::spectrograms(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.SpectrogramResponse.spectrograms)
  return _internal_spectrograms().Get(index);
}
inline ::thalamus_grpc::Spectrogram* SpectrogramResponse::add_spectrograms() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::thalamus_grpc::Spectrogram* _add = _internal_mutable_spectrograms()->Add();
  // @@protoc_insertion_point(field_add:thalamus_grpc.SpectrogramResponse.spectrograms)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>& SpectrogramResponse::spectrograms() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.SpectrogramResponse.spectrograms)
  return _internal_spectrograms();
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>&
SpectrogramResponse::_internal_spectrograms() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spectrograms_;
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Spectrogram>*
SpectrogramResponse::_internal_mutable_spectrograms() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spectrograms_;
}

// -------------------------------------------------------------------

// NodeSelector

// string name = 1;
inline void NodeSelector::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeSelector::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.NodeSelector.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeSelector::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.NodeSelector.name)
}
inline std::string* NodeSelector::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.NodeSelector.name)
  return _s;
}
inline const std::string& NodeSelector::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeSelector::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeSelector::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeSelector::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.NodeSelector.name)
  return _impl_.name_.Release();
}
inline void NodeSelector::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.NodeSelector.name)
}

// string type = 2;
inline void NodeSelector::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.ClearToEmpty();
}
inline const std::string& NodeSelector::type() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.NodeSelector.type)
  return _internal_type();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeSelector::set_type(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.NodeSelector.type)
}
inline std::string* NodeSelector::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.NodeSelector.type)
  return _s;
}
inline const std::string& NodeSelector::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.type_.Get();
}
inline void NodeSelector::_internal_set_type(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.Set(value, GetArena());
}
inline std::string* NodeSelector::_internal_mutable_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.type_.Mutable( GetArena());
}
inline std::string* NodeSelector::release_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.NodeSelector.type)
  return _impl_.type_.Release();
}
inline void NodeSelector::set_allocated_type(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.type_.IsDefault()) {
          _impl_.type_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.NodeSelector.type)
}

// -------------------------------------------------------------------

// NodeRequest

// string node = 1;
inline void NodeRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.ClearToEmpty();
}
inline const std::string& NodeRequest::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.NodeRequest.node)
  return _internal_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeRequest::set_node(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.NodeRequest.node)
}
inline std::string* NodeRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.NodeRequest.node)
  return _s;
}
inline const std::string& NodeRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_.Get();
}
inline void NodeRequest::_internal_set_node(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.Set(value, GetArena());
}
inline std::string* NodeRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_.Mutable( GetArena());
}
inline std::string* NodeRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.NodeRequest.node)
  return _impl_.node_.Release();
}
inline void NodeRequest::set_allocated_node(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_.IsDefault()) {
          _impl_.node_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.NodeRequest.node)
}

// string json = 2;
inline void NodeRequest::clear_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.ClearToEmpty();
}
inline const std::string& NodeRequest::json() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.NodeRequest.json)
  return _internal_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeRequest::set_json(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.NodeRequest.json)
}
inline std::string* NodeRequest::mutable_json() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.NodeRequest.json)
  return _s;
}
inline const std::string& NodeRequest::_internal_json() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.json_.Get();
}
inline void NodeRequest::_internal_set_json(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.Set(value, GetArena());
}
inline std::string* NodeRequest::_internal_mutable_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.json_.Mutable( GetArena());
}
inline std::string* NodeRequest::release_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.NodeRequest.json)
  return _impl_.json_.Release();
}
inline void NodeRequest::set_allocated_json(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.json_.IsDefault()) {
          _impl_.json_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.NodeRequest.json)
}

// -------------------------------------------------------------------

// NodeResponse

// string json = 1;
inline void NodeResponse::clear_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.ClearToEmpty();
}
inline const std::string& NodeResponse::json() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.NodeResponse.json)
  return _internal_json();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeResponse::set_json(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.NodeResponse.json)
}
inline std::string* NodeResponse::mutable_json() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_json();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.NodeResponse.json)
  return _s;
}
inline const std::string& NodeResponse::_internal_json() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.json_.Get();
}
inline void NodeResponse::_internal_set_json(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.Set(value, GetArena());
}
inline std::string* NodeResponse::_internal_mutable_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.json_.Mutable( GetArena());
}
inline std::string* NodeResponse::release_json() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.NodeResponse.json)
  return _impl_.json_.Release();
}
inline void NodeResponse::set_allocated_json(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.json_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.json_.IsDefault()) {
          _impl_.json_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.NodeResponse.json)
}

// -------------------------------------------------------------------

// Text

// string text = 1;
inline void Text::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.ClearToEmpty();
}
inline const std::string& Text::text() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Text.text)
  return _internal_text();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Text::set_text(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Text.text)
}
inline std::string* Text::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Text.text)
  return _s;
}
inline const std::string& Text::_internal_text() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.text_.Get();
}
inline void Text::_internal_set_text(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.Set(value, GetArena());
}
inline std::string* Text::_internal_mutable_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.text_.Mutable( GetArena());
}
inline std::string* Text::release_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Text.text)
  return _impl_.text_.Release();
}
inline void Text::set_allocated_text(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.text_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.text_.IsDefault()) {
          _impl_.text_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Text.text)
}

// uint64 time = 2;
inline void Text::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = ::uint64_t{0u};
}
inline ::uint64_t Text::time() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Text.time)
  return _internal_time();
}
inline void Text::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Text.time)
}
inline ::uint64_t Text::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void Text::_internal_set_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// StorageRecord

// .thalamus_grpc.AnalogResponse analog = 1;
inline bool StorageRecord::has_analog() const {
  return body_case() == kAnalog;
}
inline bool StorageRecord::_internal_has_analog() const {
  return body_case() == kAnalog;
}
inline void StorageRecord::set_has_analog() {
  _impl_._oneof_case_[0] = kAnalog;
}
inline void StorageRecord::clear_analog() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kAnalog) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.analog_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.analog_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::AnalogResponse* StorageRecord::release_analog() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.StorageRecord.analog)
  if (body_case() == kAnalog) {
    clear_has_body();
    auto* temp = _impl_.body_.analog_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.analog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::AnalogResponse& StorageRecord::_internal_analog() const {
  return body_case() == kAnalog ? *_impl_.body_.analog_ : reinterpret_cast<::thalamus_grpc::AnalogResponse&>(::thalamus_grpc::_AnalogResponse_default_instance_);
}
inline const ::thalamus_grpc::AnalogResponse& StorageRecord::analog() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.analog)
  return _internal_analog();
}
inline ::thalamus_grpc::AnalogResponse* StorageRecord::unsafe_arena_release_analog() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.StorageRecord.analog)
  if (body_case() == kAnalog) {
    clear_has_body();
    auto* temp = _impl_.body_.analog_;
    _impl_.body_.analog_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageRecord::unsafe_arena_set_allocated_analog(::thalamus_grpc::AnalogResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_analog();
    _impl_.body_.analog_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.StorageRecord.analog)
}
inline ::thalamus_grpc::AnalogResponse* StorageRecord::_internal_mutable_analog() {
  if (body_case() != kAnalog) {
    clear_body();
    set_has_analog();
    _impl_.body_.analog_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::AnalogResponse>(GetArena());
  }
  return _impl_.body_.analog_;
}
inline ::thalamus_grpc::AnalogResponse* StorageRecord::mutable_analog() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::AnalogResponse* _msg = _internal_mutable_analog();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StorageRecord.analog)
  return _msg;
}

// .thalamus_grpc.XsensResponse xsens = 2;
inline bool StorageRecord::has_xsens() const {
  return body_case() == kXsens;
}
inline bool StorageRecord::_internal_has_xsens() const {
  return body_case() == kXsens;
}
inline void StorageRecord::set_has_xsens() {
  _impl_._oneof_case_[0] = kXsens;
}
inline void StorageRecord::clear_xsens() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kXsens) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.xsens_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.xsens_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::XsensResponse* StorageRecord::release_xsens() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.StorageRecord.xsens)
  if (body_case() == kXsens) {
    clear_has_body();
    auto* temp = _impl_.body_.xsens_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.xsens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::XsensResponse& StorageRecord::_internal_xsens() const {
  return body_case() == kXsens ? *_impl_.body_.xsens_ : reinterpret_cast<::thalamus_grpc::XsensResponse&>(::thalamus_grpc::_XsensResponse_default_instance_);
}
inline const ::thalamus_grpc::XsensResponse& StorageRecord::xsens() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.xsens)
  return _internal_xsens();
}
inline ::thalamus_grpc::XsensResponse* StorageRecord::unsafe_arena_release_xsens() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.StorageRecord.xsens)
  if (body_case() == kXsens) {
    clear_has_body();
    auto* temp = _impl_.body_.xsens_;
    _impl_.body_.xsens_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageRecord::unsafe_arena_set_allocated_xsens(::thalamus_grpc::XsensResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_xsens();
    _impl_.body_.xsens_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.StorageRecord.xsens)
}
inline ::thalamus_grpc::XsensResponse* StorageRecord::_internal_mutable_xsens() {
  if (body_case() != kXsens) {
    clear_body();
    set_has_xsens();
    _impl_.body_.xsens_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::XsensResponse>(GetArena());
  }
  return _impl_.body_.xsens_;
}
inline ::thalamus_grpc::XsensResponse* StorageRecord::mutable_xsens() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::XsensResponse* _msg = _internal_mutable_xsens();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StorageRecord.xsens)
  return _msg;
}

// .thalamus_grpc.Event event = 3;
inline bool StorageRecord::has_event() const {
  return body_case() == kEvent;
}
inline bool StorageRecord::_internal_has_event() const {
  return body_case() == kEvent;
}
inline void StorageRecord::set_has_event() {
  _impl_._oneof_case_[0] = kEvent;
}
inline void StorageRecord::clear_event() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kEvent) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.event_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.event_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::Event* StorageRecord::release_event() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.StorageRecord.event)
  if (body_case() == kEvent) {
    clear_has_body();
    auto* temp = _impl_.body_.event_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::Event& StorageRecord::_internal_event() const {
  return body_case() == kEvent ? *_impl_.body_.event_ : reinterpret_cast<::thalamus_grpc::Event&>(::thalamus_grpc::_Event_default_instance_);
}
inline const ::thalamus_grpc::Event& StorageRecord::event() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.event)
  return _internal_event();
}
inline ::thalamus_grpc::Event* StorageRecord::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.StorageRecord.event)
  if (body_case() == kEvent) {
    clear_has_body();
    auto* temp = _impl_.body_.event_;
    _impl_.body_.event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageRecord::unsafe_arena_set_allocated_event(::thalamus_grpc::Event* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_event();
    _impl_.body_.event_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.StorageRecord.event)
}
inline ::thalamus_grpc::Event* StorageRecord::_internal_mutable_event() {
  if (body_case() != kEvent) {
    clear_body();
    set_has_event();
    _impl_.body_.event_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::Event>(GetArena());
  }
  return _impl_.body_.event_;
}
inline ::thalamus_grpc::Event* StorageRecord::mutable_event() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StorageRecord.event)
  return _msg;
}

// .thalamus_grpc.Image image = 6;
inline bool StorageRecord::has_image() const {
  return body_case() == kImage;
}
inline bool StorageRecord::_internal_has_image() const {
  return body_case() == kImage;
}
inline void StorageRecord::set_has_image() {
  _impl_._oneof_case_[0] = kImage;
}
inline void StorageRecord::clear_image() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kImage) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.image_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.image_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::Image* StorageRecord::release_image() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.StorageRecord.image)
  if (body_case() == kImage) {
    clear_has_body();
    auto* temp = _impl_.body_.image_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::Image& StorageRecord::_internal_image() const {
  return body_case() == kImage ? *_impl_.body_.image_ : reinterpret_cast<::thalamus_grpc::Image&>(::thalamus_grpc::_Image_default_instance_);
}
inline const ::thalamus_grpc::Image& StorageRecord::image() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.image)
  return _internal_image();
}
inline ::thalamus_grpc::Image* StorageRecord::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.StorageRecord.image)
  if (body_case() == kImage) {
    clear_has_body();
    auto* temp = _impl_.body_.image_;
    _impl_.body_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageRecord::unsafe_arena_set_allocated_image(::thalamus_grpc::Image* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_image();
    _impl_.body_.image_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.StorageRecord.image)
}
inline ::thalamus_grpc::Image* StorageRecord::_internal_mutable_image() {
  if (body_case() != kImage) {
    clear_body();
    set_has_image();
    _impl_.body_.image_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::Image>(GetArena());
  }
  return _impl_.body_.image_;
}
inline ::thalamus_grpc::Image* StorageRecord::mutable_image() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StorageRecord.image)
  return _msg;
}

// .thalamus_grpc.Text text = 7;
inline bool StorageRecord::has_text() const {
  return body_case() == kText;
}
inline bool StorageRecord::_internal_has_text() const {
  return body_case() == kText;
}
inline void StorageRecord::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void StorageRecord::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kText) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.text_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.text_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::Text* StorageRecord::release_text() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.StorageRecord.text)
  if (body_case() == kText) {
    clear_has_body();
    auto* temp = _impl_.body_.text_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::Text& StorageRecord::_internal_text() const {
  return body_case() == kText ? *_impl_.body_.text_ : reinterpret_cast<::thalamus_grpc::Text&>(::thalamus_grpc::_Text_default_instance_);
}
inline const ::thalamus_grpc::Text& StorageRecord::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.text)
  return _internal_text();
}
inline ::thalamus_grpc::Text* StorageRecord::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.StorageRecord.text)
  if (body_case() == kText) {
    clear_has_body();
    auto* temp = _impl_.body_.text_;
    _impl_.body_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void StorageRecord::unsafe_arena_set_allocated_text(::thalamus_grpc::Text* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_text();
    _impl_.body_.text_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.StorageRecord.text)
}
inline ::thalamus_grpc::Text* StorageRecord::_internal_mutable_text() {
  if (body_case() != kText) {
    clear_body();
    set_has_text();
    _impl_.body_.text_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::Text>(GetArena());
  }
  return _impl_.body_.text_;
}
inline ::thalamus_grpc::Text* StorageRecord::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::Text* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StorageRecord.text)
  return _msg;
}

// uint64 time = 4;
inline void StorageRecord::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = ::uint64_t{0u};
}
inline ::uint64_t StorageRecord::time() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.time)
  return _internal_time();
}
inline void StorageRecord::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.StorageRecord.time)
}
inline ::uint64_t StorageRecord::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void StorageRecord::_internal_set_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// string node = 5;
inline void StorageRecord::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.ClearToEmpty();
}
inline const std::string& StorageRecord::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StorageRecord.node)
  return _internal_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StorageRecord::set_node(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.StorageRecord.node)
}
inline std::string* StorageRecord::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StorageRecord.node)
  return _s;
}
inline const std::string& StorageRecord::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_.Get();
}
inline void StorageRecord::_internal_set_node(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.Set(value, GetArena());
}
inline std::string* StorageRecord::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_.Mutable( GetArena());
}
inline std::string* StorageRecord::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.StorageRecord.node)
  return _impl_.node_.Release();
}
inline void StorageRecord::set_allocated_node(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.node_.IsDefault()) {
          _impl_.node_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.StorageRecord.node)
}

inline bool StorageRecord::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void StorageRecord::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline StorageRecord::BodyCase StorageRecord::body_case() const {
  return StorageRecord::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ImageRequest

// .thalamus_grpc.NodeSelector node = 1;
inline bool ImageRequest::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline void ImageRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ != nullptr) _impl_.node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thalamus_grpc::NodeSelector& ImageRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::thalamus_grpc::NodeSelector* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::thalamus_grpc::NodeSelector&>(::thalamus_grpc::_NodeSelector_default_instance_);
}
inline const ::thalamus_grpc::NodeSelector& ImageRequest::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ImageRequest.node)
  return _internal_node();
}
inline void ImageRequest::unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.ImageRequest.node)
}
inline ::thalamus_grpc::NodeSelector* ImageRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* released = _impl_.node_;
  _impl_.node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thalamus_grpc::NodeSelector* ImageRequest::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.ImageRequest.node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::thalamus_grpc::NodeSelector* ImageRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::NodeSelector>(GetArena());
    _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(p);
  }
  return _impl_.node_;
}
inline ::thalamus_grpc::NodeSelector* ImageRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::thalamus_grpc::NodeSelector* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.ImageRequest.node)
  return _msg;
}
inline void ImageRequest::set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.ImageRequest.node)
}

// double framerate = 2;
inline void ImageRequest::clear_framerate() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framerate_ = 0;
}
inline double ImageRequest::framerate() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ImageRequest.framerate)
  return _internal_framerate();
}
inline void ImageRequest::set_framerate(double value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ImageRequest.framerate)
}
inline double ImageRequest::_internal_framerate() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.framerate_;
}
inline void ImageRequest::_internal_set_framerate(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.framerate_ = value;
}

// -------------------------------------------------------------------

// Image

// repeated bytes data = 1;
inline int Image::_internal_data_size() const {
  return _internal_data().size();
}
inline int Image::data_size() const {
  return _internal_data_size();
}
inline void Image::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline std::string* Image::add_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_data()->Add();
  // @@protoc_insertion_point(field_add_mutable:thalamus_grpc.Image.data)
  return _s;
}
inline const std::string& Image::data(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.data)
  return _internal_data().Get(index);
}
inline std::string* Image::mutable_data(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Image.data)
  return _internal_mutable_data()->Mutable(index);
}
inline void Image::set_data(int index, const std::string& value) {
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.data)
}
inline void Image::set_data(int index, std::string&& value) {
  _internal_mutable_data()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.data)
}
inline void Image::set_data(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_data()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:thalamus_grpc.Image.data)
}
inline void Image::set_data(int index, const void* value,
                              std::size_t size) {
  _internal_mutable_data()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:thalamus_grpc.Image.data)
}
inline void Image::set_data(int index, absl::string_view value) {
  _internal_mutable_data()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:thalamus_grpc.Image.data)
}
inline void Image::add_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.Image.data)
}
inline void Image::add_data(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:thalamus_grpc.Image.data)
}
inline void Image::add_data(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:thalamus_grpc.Image.data)
}
inline void Image::add_data(const void* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:thalamus_grpc.Image.data)
}
inline void Image::add_data(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:thalamus_grpc.Image.data)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Image::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.Image.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Image::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.Image.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Image::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Image::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// uint32 width = 2;
inline void Image::clear_width() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = 0u;
}
inline ::uint32_t Image::width() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.width)
  return _internal_width();
}
inline void Image::set_width(::uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.width)
}
inline ::uint32_t Image::_internal_width() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.width_;
}
inline void Image::_internal_set_width(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.width_ = value;
}

// uint32 height = 3;
inline void Image::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
}
inline ::uint32_t Image::height() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.height)
  return _internal_height();
}
inline void Image::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.height)
}
inline ::uint32_t Image::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Image::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// .thalamus_grpc.Image.Format format = 4;
inline void Image::clear_format() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_ = 0;
}
inline ::thalamus_grpc::Image_Format Image::format() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.format)
  return _internal_format();
}
inline void Image::set_format(::thalamus_grpc::Image_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.format)
}
inline ::thalamus_grpc::Image_Format Image::_internal_format() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::thalamus_grpc::Image_Format>(_impl_.format_);
}
inline void Image::_internal_set_format(::thalamus_grpc::Image_Format value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.format_ = value;
}

// uint64 frame_interval = 5;
inline void Image::clear_frame_interval() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_interval_ = ::uint64_t{0u};
}
inline ::uint64_t Image::frame_interval() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.frame_interval)
  return _internal_frame_interval();
}
inline void Image::set_frame_interval(::uint64_t value) {
  _internal_set_frame_interval(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.frame_interval)
}
inline ::uint64_t Image::_internal_frame_interval() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_interval_;
}
inline void Image::_internal_set_frame_interval(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_interval_ = value;
}

// bool last = 6;
inline void Image::clear_last() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_ = false;
}
inline bool Image::last() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.last)
  return _internal_last();
}
inline void Image::set_last(bool value) {
  _internal_set_last(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.last)
}
inline bool Image::_internal_last() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.last_;
}
inline void Image::_internal_set_last(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.last_ = value;
}

// bool bigendian = 7;
inline void Image::clear_bigendian() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bigendian_ = false;
}
inline bool Image::bigendian() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Image.bigendian)
  return _internal_bigendian();
}
inline void Image::set_bigendian(bool value) {
  _internal_set_bigendian(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Image.bigendian)
}
inline bool Image::_internal_bigendian() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bigendian_;
}
inline void Image::_internal_set_bigendian(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bigendian_ = value;
}

// -------------------------------------------------------------------

// Ping

// uint32 id = 1;
inline void Ping::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t Ping::id() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Ping.id)
  return _internal_id();
}
inline void Ping::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Ping.id)
}
inline ::uint32_t Ping::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Ping::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// bytes payload = 2;
inline void Ping::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Ping::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Ping.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Ping::set_payload(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Ping.payload)
}
inline std::string* Ping::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Ping.payload)
  return _s;
}
inline const std::string& Ping::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.Get();
}
inline void Ping::_internal_set_payload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* Ping::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* Ping::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Ping.payload)
  return _impl_.payload_.Release();
}
inline void Ping::set_allocated_payload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Ping.payload)
}

// -------------------------------------------------------------------

// Pong

// uint32 id = 2;
inline void Pong::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t Pong::id() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Pong.id)
  return _internal_id();
}
inline void Pong::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Pong.id)
}
inline ::uint32_t Pong::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void Pong::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// bytes payload = 3;
inline void Pong::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Pong::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Pong.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Pong::set_payload(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Pong.payload)
}
inline std::string* Pong::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Pong.payload)
  return _s;
}
inline const std::string& Pong::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.Get();
}
inline void Pong::_internal_set_payload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* Pong::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* Pong::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Pong.payload)
  return _impl_.payload_.Release();
}
inline void Pong::set_allocated_payload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Pong.payload)
}

// -------------------------------------------------------------------

// RemoteNodeMessage

// .thalamus_grpc.AnalogRequest request = 1;
inline bool RemoteNodeMessage::has_request() const {
  return body_case() == kRequest;
}
inline bool RemoteNodeMessage::_internal_has_request() const {
  return body_case() == kRequest;
}
inline void RemoteNodeMessage::set_has_request() {
  _impl_._oneof_case_[0] = kRequest;
}
inline void RemoteNodeMessage::clear_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.request_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::AnalogRequest* RemoteNodeMessage::release_request() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.RemoteNodeMessage.request)
  if (body_case() == kRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::AnalogRequest& RemoteNodeMessage::_internal_request() const {
  return body_case() == kRequest ? *_impl_.body_.request_ : reinterpret_cast<::thalamus_grpc::AnalogRequest&>(::thalamus_grpc::_AnalogRequest_default_instance_);
}
inline const ::thalamus_grpc::AnalogRequest& RemoteNodeMessage::request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.RemoteNodeMessage.request)
  return _internal_request();
}
inline ::thalamus_grpc::AnalogRequest* RemoteNodeMessage::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.RemoteNodeMessage.request)
  if (body_case() == kRequest) {
    clear_has_body();
    auto* temp = _impl_.body_.request_;
    _impl_.body_.request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteNodeMessage::unsafe_arena_set_allocated_request(::thalamus_grpc::AnalogRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_request();
    _impl_.body_.request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.RemoteNodeMessage.request)
}
inline ::thalamus_grpc::AnalogRequest* RemoteNodeMessage::_internal_mutable_request() {
  if (body_case() != kRequest) {
    clear_body();
    set_has_request();
    _impl_.body_.request_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::AnalogRequest>(GetArena());
  }
  return _impl_.body_.request_;
}
inline ::thalamus_grpc::AnalogRequest* RemoteNodeMessage::mutable_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::AnalogRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.RemoteNodeMessage.request)
  return _msg;
}

// .thalamus_grpc.AnalogResponse data = 2;
inline bool RemoteNodeMessage::has_data() const {
  return body_case() == kData;
}
inline bool RemoteNodeMessage::_internal_has_data() const {
  return body_case() == kData;
}
inline void RemoteNodeMessage::set_has_data() {
  _impl_._oneof_case_[0] = kData;
}
inline void RemoteNodeMessage::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kData) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.data_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::AnalogResponse* RemoteNodeMessage::release_data() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.RemoteNodeMessage.data)
  if (body_case() == kData) {
    clear_has_body();
    auto* temp = _impl_.body_.data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::AnalogResponse& RemoteNodeMessage::_internal_data() const {
  return body_case() == kData ? *_impl_.body_.data_ : reinterpret_cast<::thalamus_grpc::AnalogResponse&>(::thalamus_grpc::_AnalogResponse_default_instance_);
}
inline const ::thalamus_grpc::AnalogResponse& RemoteNodeMessage::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.RemoteNodeMessage.data)
  return _internal_data();
}
inline ::thalamus_grpc::AnalogResponse* RemoteNodeMessage::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.RemoteNodeMessage.data)
  if (body_case() == kData) {
    clear_has_body();
    auto* temp = _impl_.body_.data_;
    _impl_.body_.data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteNodeMessage::unsafe_arena_set_allocated_data(::thalamus_grpc::AnalogResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_data();
    _impl_.body_.data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.RemoteNodeMessage.data)
}
inline ::thalamus_grpc::AnalogResponse* RemoteNodeMessage::_internal_mutable_data() {
  if (body_case() != kData) {
    clear_body();
    set_has_data();
    _impl_.body_.data_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::AnalogResponse>(GetArena());
  }
  return _impl_.body_.data_;
}
inline ::thalamus_grpc::AnalogResponse* RemoteNodeMessage::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::AnalogResponse* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.RemoteNodeMessage.data)
  return _msg;
}

// .thalamus_grpc.Ping ping = 3;
inline bool RemoteNodeMessage::has_ping() const {
  return body_case() == kPing;
}
inline bool RemoteNodeMessage::_internal_has_ping() const {
  return body_case() == kPing;
}
inline void RemoteNodeMessage::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void RemoteNodeMessage::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kPing) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.ping_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.ping_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::Ping* RemoteNodeMessage::release_ping() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.RemoteNodeMessage.ping)
  if (body_case() == kPing) {
    clear_has_body();
    auto* temp = _impl_.body_.ping_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::Ping& RemoteNodeMessage::_internal_ping() const {
  return body_case() == kPing ? *_impl_.body_.ping_ : reinterpret_cast<::thalamus_grpc::Ping&>(::thalamus_grpc::_Ping_default_instance_);
}
inline const ::thalamus_grpc::Ping& RemoteNodeMessage::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.RemoteNodeMessage.ping)
  return _internal_ping();
}
inline ::thalamus_grpc::Ping* RemoteNodeMessage::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.RemoteNodeMessage.ping)
  if (body_case() == kPing) {
    clear_has_body();
    auto* temp = _impl_.body_.ping_;
    _impl_.body_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteNodeMessage::unsafe_arena_set_allocated_ping(::thalamus_grpc::Ping* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_ping();
    _impl_.body_.ping_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.RemoteNodeMessage.ping)
}
inline ::thalamus_grpc::Ping* RemoteNodeMessage::_internal_mutable_ping() {
  if (body_case() != kPing) {
    clear_body();
    set_has_ping();
    _impl_.body_.ping_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::Ping>(GetArena());
  }
  return _impl_.body_.ping_;
}
inline ::thalamus_grpc::Ping* RemoteNodeMessage::mutable_ping() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.RemoteNodeMessage.ping)
  return _msg;
}

// .thalamus_grpc.Pong pong = 4;
inline bool RemoteNodeMessage::has_pong() const {
  return body_case() == kPong;
}
inline bool RemoteNodeMessage::_internal_has_pong() const {
  return body_case() == kPong;
}
inline void RemoteNodeMessage::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void RemoteNodeMessage::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kPong) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.pong_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.pong_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::Pong* RemoteNodeMessage::release_pong() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.RemoteNodeMessage.pong)
  if (body_case() == kPong) {
    clear_has_body();
    auto* temp = _impl_.body_.pong_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::Pong& RemoteNodeMessage::_internal_pong() const {
  return body_case() == kPong ? *_impl_.body_.pong_ : reinterpret_cast<::thalamus_grpc::Pong&>(::thalamus_grpc::_Pong_default_instance_);
}
inline const ::thalamus_grpc::Pong& RemoteNodeMessage::pong() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.RemoteNodeMessage.pong)
  return _internal_pong();
}
inline ::thalamus_grpc::Pong* RemoteNodeMessage::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.RemoteNodeMessage.pong)
  if (body_case() == kPong) {
    clear_has_body();
    auto* temp = _impl_.body_.pong_;
    _impl_.body_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoteNodeMessage::unsafe_arena_set_allocated_pong(::thalamus_grpc::Pong* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_pong();
    _impl_.body_.pong_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.RemoteNodeMessage.pong)
}
inline ::thalamus_grpc::Pong* RemoteNodeMessage::_internal_mutable_pong() {
  if (body_case() != kPong) {
    clear_body();
    set_has_pong();
    _impl_.body_.pong_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::Pong>(GetArena());
  }
  return _impl_.body_.pong_;
}
inline ::thalamus_grpc::Pong* RemoteNodeMessage::mutable_pong() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::Pong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.RemoteNodeMessage.pong)
  return _msg;
}

inline bool RemoteNodeMessage::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void RemoteNodeMessage::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline RemoteNodeMessage::BodyCase RemoteNodeMessage::body_case() const {
  return RemoteNodeMessage::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ReplayRequest

// string filename = 1;
inline void ReplayRequest::clear_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.ClearToEmpty();
}
inline const std::string& ReplayRequest::filename() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ReplayRequest.filename)
  return _internal_filename();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ReplayRequest::set_filename(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.ReplayRequest.filename)
}
inline std::string* ReplayRequest::mutable_filename() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.ReplayRequest.filename)
  return _s;
}
inline const std::string& ReplayRequest::_internal_filename() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.filename_.Get();
}
inline void ReplayRequest::_internal_set_filename(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.Set(value, GetArena());
}
inline std::string* ReplayRequest::_internal_mutable_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.filename_.Mutable( GetArena());
}
inline std::string* ReplayRequest::release_filename() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.ReplayRequest.filename)
  return _impl_.filename_.Release();
}
inline void ReplayRequest::set_allocated_filename(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.filename_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filename_.IsDefault()) {
          _impl_.filename_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.ReplayRequest.filename)
}

// repeated string nodes = 2;
inline int ReplayRequest::_internal_nodes_size() const {
  return _internal_nodes().size();
}
inline int ReplayRequest::nodes_size() const {
  return _internal_nodes_size();
}
inline void ReplayRequest::clear_nodes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nodes_.Clear();
}
inline std::string* ReplayRequest::add_nodes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_nodes()->Add();
  // @@protoc_insertion_point(field_add_mutable:thalamus_grpc.ReplayRequest.nodes)
  return _s;
}
inline const std::string& ReplayRequest::nodes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ReplayRequest.nodes)
  return _internal_nodes().Get(index);
}
inline std::string* ReplayRequest::mutable_nodes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.ReplayRequest.nodes)
  return _internal_mutable_nodes()->Mutable(index);
}
inline void ReplayRequest::set_nodes(int index, const std::string& value) {
  _internal_mutable_nodes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::set_nodes(int index, std::string&& value) {
  _internal_mutable_nodes()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::set_nodes(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_nodes()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::set_nodes(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_nodes()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::set_nodes(int index, absl::string_view value) {
  _internal_mutable_nodes()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::add_nodes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_nodes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::add_nodes(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_nodes()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::add_nodes(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_nodes()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::add_nodes(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_nodes()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:thalamus_grpc.ReplayRequest.nodes)
}
inline void ReplayRequest::add_nodes(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_nodes()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:thalamus_grpc.ReplayRequest.nodes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReplayRequest::nodes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.ReplayRequest.nodes)
  return _internal_nodes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReplayRequest::mutable_nodes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.ReplayRequest.nodes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_nodes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ReplayRequest::_internal_nodes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nodes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ReplayRequest::_internal_mutable_nodes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.nodes_;
}

// -------------------------------------------------------------------

// XsensSegment

// uint32 id = 1;
inline void XsensSegment::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = 0u;
}
inline ::uint32_t XsensSegment::id() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.id)
  return _internal_id();
}
inline void XsensSegment::set_id(::uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.id)
}
inline ::uint32_t XsensSegment::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void XsensSegment::_internal_set_id(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// float x = 2;
inline void XsensSegment::clear_x() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = 0;
}
inline float XsensSegment::x() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.x)
  return _internal_x();
}
inline void XsensSegment::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.x)
}
inline float XsensSegment::_internal_x() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.x_;
}
inline void XsensSegment::_internal_set_x(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.x_ = value;
}

// float y = 3;
inline void XsensSegment::clear_y() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = 0;
}
inline float XsensSegment::y() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.y)
  return _internal_y();
}
inline void XsensSegment::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.y)
}
inline float XsensSegment::_internal_y() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.y_;
}
inline void XsensSegment::_internal_set_y(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.y_ = value;
}

// float z = 4;
inline void XsensSegment::clear_z() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = 0;
}
inline float XsensSegment::z() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.z)
  return _internal_z();
}
inline void XsensSegment::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.z)
}
inline float XsensSegment::_internal_z() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.z_;
}
inline void XsensSegment::_internal_set_z(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.z_ = value;
}

// float q0 = 5;
inline void XsensSegment::clear_q0() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q0_ = 0;
}
inline float XsensSegment::q0() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.q0)
  return _internal_q0();
}
inline void XsensSegment::set_q0(float value) {
  _internal_set_q0(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.q0)
}
inline float XsensSegment::_internal_q0() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.q0_;
}
inline void XsensSegment::_internal_set_q0(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q0_ = value;
}

// float q1 = 6;
inline void XsensSegment::clear_q1() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q1_ = 0;
}
inline float XsensSegment::q1() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.q1)
  return _internal_q1();
}
inline void XsensSegment::set_q1(float value) {
  _internal_set_q1(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.q1)
}
inline float XsensSegment::_internal_q1() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.q1_;
}
inline void XsensSegment::_internal_set_q1(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q1_ = value;
}

// float q2 = 7;
inline void XsensSegment::clear_q2() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q2_ = 0;
}
inline float XsensSegment::q2() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.q2)
  return _internal_q2();
}
inline void XsensSegment::set_q2(float value) {
  _internal_set_q2(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.q2)
}
inline float XsensSegment::_internal_q2() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.q2_;
}
inline void XsensSegment::_internal_set_q2(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q2_ = value;
}

// float q3 = 8;
inline void XsensSegment::clear_q3() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q3_ = 0;
}
inline float XsensSegment::q3() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.q3)
  return _internal_q3();
}
inline void XsensSegment::set_q3(float value) {
  _internal_set_q3(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.q3)
}
inline float XsensSegment::_internal_q3() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.q3_;
}
inline void XsensSegment::_internal_set_q3(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.q3_ = value;
}

// uint32 frame = 9;
inline void XsensSegment::clear_frame() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_ = 0u;
}
inline ::uint32_t XsensSegment::frame() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.frame)
  return _internal_frame();
}
inline void XsensSegment::set_frame(::uint32_t value) {
  _internal_set_frame(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.frame)
}
inline ::uint32_t XsensSegment::_internal_frame() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_;
}
inline void XsensSegment::_internal_set_frame(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_ = value;
}

// uint32 time = 10;
inline void XsensSegment::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = 0u;
}
inline ::uint32_t XsensSegment::time() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensSegment.time)
  return _internal_time();
}
inline void XsensSegment::set_time(::uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensSegment.time)
}
inline ::uint32_t XsensSegment::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void XsensSegment::_internal_set_time(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// XsensResponse

// repeated .thalamus_grpc.XsensSegment segments = 1;
inline int XsensResponse::_internal_segments_size() const {
  return _internal_segments().size();
}
inline int XsensResponse::segments_size() const {
  return _internal_segments_size();
}
inline void XsensResponse::clear_segments() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.segments_.Clear();
}
inline ::thalamus_grpc::XsensSegment* XsensResponse::mutable_segments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.XsensResponse.segments)
  return _internal_mutable_segments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>* XsensResponse::mutable_segments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.XsensResponse.segments)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_segments();
}
inline const ::thalamus_grpc::XsensSegment& XsensResponse::segments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensResponse.segments)
  return _internal_segments().Get(index);
}
inline ::thalamus_grpc::XsensSegment* XsensResponse::add_segments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::thalamus_grpc::XsensSegment* _add = _internal_mutable_segments()->Add();
  // @@protoc_insertion_point(field_add:thalamus_grpc.XsensResponse.segments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>& XsensResponse::segments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.XsensResponse.segments)
  return _internal_segments();
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>&
XsensResponse::_internal_segments() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.segments_;
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::XsensSegment>*
XsensResponse::_internal_mutable_segments() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.segments_;
}

// string pose_name = 2;
inline void XsensResponse::clear_pose_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pose_name_.ClearToEmpty();
}
inline const std::string& XsensResponse::pose_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.XsensResponse.pose_name)
  return _internal_pose_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void XsensResponse::set_pose_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pose_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.XsensResponse.pose_name)
}
inline std::string* XsensResponse::mutable_pose_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pose_name();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.XsensResponse.pose_name)
  return _s;
}
inline const std::string& XsensResponse::_internal_pose_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pose_name_.Get();
}
inline void XsensResponse::_internal_set_pose_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pose_name_.Set(value, GetArena());
}
inline std::string* XsensResponse::_internal_mutable_pose_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pose_name_.Mutable( GetArena());
}
inline std::string* XsensResponse::release_pose_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.XsensResponse.pose_name)
  return _impl_.pose_name_.Release();
}
inline void XsensResponse::set_allocated_pose_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pose_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pose_name_.IsDefault()) {
          _impl_.pose_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.XsensResponse.pose_name)
}

// -------------------------------------------------------------------

// StringMessage

// string value = 1;
inline void StringMessage::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& StringMessage::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StringMessage.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void StringMessage::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.StringMessage.value)
}
inline std::string* StringMessage::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StringMessage.value)
  return _s;
}
inline const std::string& StringMessage::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void StringMessage::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* StringMessage::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* StringMessage::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.StringMessage.value)
  return _impl_.value_.Release();
}
inline void StringMessage::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.StringMessage.value)
}

// -------------------------------------------------------------------

// ModalitiesMessage

// repeated .thalamus_grpc.Modalities values = 1;
inline int ModalitiesMessage::_internal_values_size() const {
  return _internal_values().size();
}
inline int ModalitiesMessage::values_size() const {
  return _internal_values_size();
}
inline void ModalitiesMessage::clear_values() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.values_.Clear();
}
inline ::thalamus_grpc::Modalities ModalitiesMessage::values(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ModalitiesMessage.values)
  return static_cast<::thalamus_grpc::Modalities>(_internal_values().Get(index));
}
inline void ModalitiesMessage::set_values(int index, ::thalamus_grpc::Modalities value) {
  _internal_mutable_values()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ModalitiesMessage.values)
}
inline void ModalitiesMessage::add_values(::thalamus_grpc::Modalities value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_values()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.ModalitiesMessage.values)
}
inline const ::google::protobuf::RepeatedField<int>& ModalitiesMessage::values() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.ModalitiesMessage.values)
  return _internal_values();
}
inline ::google::protobuf::RepeatedField<int>* ModalitiesMessage::mutable_values()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.ModalitiesMessage.values)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_values();
}
inline const ::google::protobuf::RepeatedField<int>& ModalitiesMessage::_internal_values()
    const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.values_;
}
inline ::google::protobuf::RepeatedField<int>* ModalitiesMessage::_internal_mutable_values() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.values_;
}

// -------------------------------------------------------------------

// StringListMessage

// repeated string value = 1;
inline int StringListMessage::_internal_value_size() const {
  return _internal_value().size();
}
inline int StringListMessage::value_size() const {
  return _internal_value_size();
}
inline void StringListMessage::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Clear();
}
inline std::string* StringListMessage::add_value()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_value()->Add();
  // @@protoc_insertion_point(field_add_mutable:thalamus_grpc.StringListMessage.value)
  return _s;
}
inline const std::string& StringListMessage::value(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.StringListMessage.value)
  return _internal_value().Get(index);
}
inline std::string* StringListMessage::mutable_value(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.StringListMessage.value)
  return _internal_mutable_value()->Mutable(index);
}
inline void StringListMessage::set_value(int index, const std::string& value) {
  _internal_mutable_value()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::set_value(int index, std::string&& value) {
  _internal_mutable_value()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::set_value(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_value()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::set_value(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_value()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::set_value(int index, absl::string_view value) {
  _internal_mutable_value()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::add_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::add_value(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::add_value(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::add_value(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:thalamus_grpc.StringListMessage.value)
}
inline void StringListMessage::add_value(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_value()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:thalamus_grpc.StringListMessage.value)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringListMessage::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.StringListMessage.value)
  return _internal_value();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringListMessage::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.StringListMessage.value)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_value();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
StringListMessage::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
StringListMessage::_internal_mutable_value() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.value_;
}

// -------------------------------------------------------------------

// EvalResponse

// string value = 1;
inline void EvalResponse::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& EvalResponse::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.EvalResponse.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EvalResponse::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.EvalResponse.value)
}
inline std::string* EvalResponse::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.EvalResponse.value)
  return _s;
}
inline const std::string& EvalResponse::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void EvalResponse::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* EvalResponse::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* EvalResponse::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.EvalResponse.value)
  return _impl_.value_.Release();
}
inline void EvalResponse::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.EvalResponse.value)
}

// uint64 id = 2;
inline void EvalResponse::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t EvalResponse::id() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.EvalResponse.id)
  return _internal_id();
}
inline void EvalResponse::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.EvalResponse.id)
}
inline ::uint64_t EvalResponse::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void EvalResponse::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// EvalRequest

// string code = 1;
inline void EvalRequest::clear_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.ClearToEmpty();
}
inline const std::string& EvalRequest::code() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.EvalRequest.code)
  return _internal_code();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EvalRequest::set_code(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.EvalRequest.code)
}
inline std::string* EvalRequest::mutable_code() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.EvalRequest.code)
  return _s;
}
inline const std::string& EvalRequest::_internal_code() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.code_.Get();
}
inline void EvalRequest::_internal_set_code(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.Set(value, GetArena());
}
inline std::string* EvalRequest::_internal_mutable_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.code_.Mutable( GetArena());
}
inline std::string* EvalRequest::release_code() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.EvalRequest.code)
  return _impl_.code_.Release();
}
inline void EvalRequest::set_allocated_code(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.code_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.code_.IsDefault()) {
          _impl_.code_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.EvalRequest.code)
}

// uint64 id = 2;
inline void EvalRequest::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t EvalRequest::id() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.EvalRequest.id)
  return _internal_id();
}
inline void EvalRequest::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.EvalRequest.id)
}
inline ::uint64_t EvalRequest::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void EvalRequest::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// AnalogRequest

// .thalamus_grpc.NodeSelector node = 1;
inline bool AnalogRequest::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline void AnalogRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ != nullptr) _impl_.node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thalamus_grpc::NodeSelector& AnalogRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::thalamus_grpc::NodeSelector* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::thalamus_grpc::NodeSelector&>(::thalamus_grpc::_NodeSelector_default_instance_);
}
inline const ::thalamus_grpc::NodeSelector& AnalogRequest::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogRequest.node)
  return _internal_node();
}
inline void AnalogRequest::unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.AnalogRequest.node)
}
inline ::thalamus_grpc::NodeSelector* AnalogRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* released = _impl_.node_;
  _impl_.node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thalamus_grpc::NodeSelector* AnalogRequest::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.AnalogRequest.node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::thalamus_grpc::NodeSelector* AnalogRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::NodeSelector>(GetArena());
    _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(p);
  }
  return _impl_.node_;
}
inline ::thalamus_grpc::NodeSelector* AnalogRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::thalamus_grpc::NodeSelector* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.AnalogRequest.node)
  return _msg;
}
inline void AnalogRequest::set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.AnalogRequest.node)
}

// repeated int32 channels = 2;
inline int AnalogRequest::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int AnalogRequest::channels_size() const {
  return _internal_channels_size();
}
inline void AnalogRequest::clear_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_.Clear();
}
inline ::int32_t AnalogRequest::channels(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogRequest.channels)
  return _internal_channels().Get(index);
}
inline void AnalogRequest::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.AnalogRequest.channels)
}
inline void AnalogRequest::add_channels(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channels()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.AnalogRequest.channels)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& AnalogRequest::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.AnalogRequest.channels)
  return _internal_channels();
}
inline ::google::protobuf::RepeatedField<::int32_t>* AnalogRequest::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.AnalogRequest.channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channels();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
AnalogRequest::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* AnalogRequest::_internal_mutable_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channels_;
}

// repeated string channel_names = 3;
inline int AnalogRequest::_internal_channel_names_size() const {
  return _internal_channel_names().size();
}
inline int AnalogRequest::channel_names_size() const {
  return _internal_channel_names_size();
}
inline void AnalogRequest::clear_channel_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_names_.Clear();
}
inline std::string* AnalogRequest::add_channel_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_channel_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:thalamus_grpc.AnalogRequest.channel_names)
  return _s;
}
inline const std::string& AnalogRequest::channel_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogRequest.channel_names)
  return _internal_channel_names().Get(index);
}
inline std::string* AnalogRequest::mutable_channel_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.AnalogRequest.channel_names)
  return _internal_mutable_channel_names()->Mutable(index);
}
inline void AnalogRequest::set_channel_names(int index, const std::string& value) {
  _internal_mutable_channel_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::set_channel_names(int index, std::string&& value) {
  _internal_mutable_channel_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::set_channel_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_channel_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::set_channel_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_channel_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::set_channel_names(int index, absl::string_view value) {
  _internal_mutable_channel_names()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::add_channel_names(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::add_channel_names(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::add_channel_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::add_channel_names(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:thalamus_grpc.AnalogRequest.channel_names)
}
inline void AnalogRequest::add_channel_names(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:thalamus_grpc.AnalogRequest.channel_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnalogRequest::channel_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.AnalogRequest.channel_names)
  return _internal_channel_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnalogRequest::mutable_channel_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.AnalogRequest.channel_names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channel_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AnalogRequest::_internal_channel_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AnalogRequest::_internal_mutable_channel_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channel_names_;
}

// -------------------------------------------------------------------

// InjectAnalogRequest

// string node = 1;
inline bool InjectAnalogRequest::has_node() const {
  return body_case() == kNode;
}
inline void InjectAnalogRequest::set_has_node() {
  _impl_._oneof_case_[0] = kNode;
}
inline void InjectAnalogRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kNode) {
    _impl_.body_.node_.Destroy();
    clear_has_body();
  }
}
inline const std::string& InjectAnalogRequest::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.InjectAnalogRequest.node)
  return _internal_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InjectAnalogRequest::set_node(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kNode) {
    clear_body();

    set_has_node();
    _impl_.body_.node_.InitDefault();
  }
  _impl_.body_.node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.InjectAnalogRequest.node)
}
inline std::string* InjectAnalogRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.InjectAnalogRequest.node)
  return _s;
}
inline const std::string& InjectAnalogRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (body_case() != kNode) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.body_.node_.Get();
}
inline void InjectAnalogRequest::_internal_set_node(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kNode) {
    clear_body();

    set_has_node();
    _impl_.body_.node_.InitDefault();
  }
  _impl_.body_.node_.Set(value, GetArena());
}
inline std::string* InjectAnalogRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kNode) {
    clear_body();

    set_has_node();
    _impl_.body_.node_.InitDefault();
  }
  return _impl_.body_.node_.Mutable( GetArena());
}
inline std::string* InjectAnalogRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.InjectAnalogRequest.node)
  if (body_case() != kNode) {
    return nullptr;
  }
  clear_has_body();
  return _impl_.body_.node_.Release();
}
inline void InjectAnalogRequest::set_allocated_node(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_body()) {
    clear_body();
  }
  if (value != nullptr) {
    set_has_node();
    _impl_.body_.node_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.InjectAnalogRequest.node)
}

// .thalamus_grpc.AnalogResponse signal = 2;
inline bool InjectAnalogRequest::has_signal() const {
  return body_case() == kSignal;
}
inline bool InjectAnalogRequest::_internal_has_signal() const {
  return body_case() == kSignal;
}
inline void InjectAnalogRequest::set_has_signal() {
  _impl_._oneof_case_[0] = kSignal;
}
inline void InjectAnalogRequest::clear_signal() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kSignal) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.signal_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.signal_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::AnalogResponse* InjectAnalogRequest::release_signal() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.InjectAnalogRequest.signal)
  if (body_case() == kSignal) {
    clear_has_body();
    auto* temp = _impl_.body_.signal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::AnalogResponse& InjectAnalogRequest::_internal_signal() const {
  return body_case() == kSignal ? *_impl_.body_.signal_ : reinterpret_cast<::thalamus_grpc::AnalogResponse&>(::thalamus_grpc::_AnalogResponse_default_instance_);
}
inline const ::thalamus_grpc::AnalogResponse& InjectAnalogRequest::signal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.InjectAnalogRequest.signal)
  return _internal_signal();
}
inline ::thalamus_grpc::AnalogResponse* InjectAnalogRequest::unsafe_arena_release_signal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.InjectAnalogRequest.signal)
  if (body_case() == kSignal) {
    clear_has_body();
    auto* temp = _impl_.body_.signal_;
    _impl_.body_.signal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InjectAnalogRequest::unsafe_arena_set_allocated_signal(::thalamus_grpc::AnalogResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_signal();
    _impl_.body_.signal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.InjectAnalogRequest.signal)
}
inline ::thalamus_grpc::AnalogResponse* InjectAnalogRequest::_internal_mutable_signal() {
  if (body_case() != kSignal) {
    clear_body();
    set_has_signal();
    _impl_.body_.signal_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::AnalogResponse>(GetArena());
  }
  return _impl_.body_.signal_;
}
inline ::thalamus_grpc::AnalogResponse* InjectAnalogRequest::mutable_signal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::AnalogResponse* _msg = _internal_mutable_signal();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.InjectAnalogRequest.signal)
  return _msg;
}

inline bool InjectAnalogRequest::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void InjectAnalogRequest::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline InjectAnalogRequest::BodyCase InjectAnalogRequest::body_case() const {
  return InjectAnalogRequest::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// InjectTextRequest

// string node = 1;
inline bool InjectTextRequest::has_node() const {
  return body_case() == kNode;
}
inline void InjectTextRequest::set_has_node() {
  _impl_._oneof_case_[0] = kNode;
}
inline void InjectTextRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kNode) {
    _impl_.body_.node_.Destroy();
    clear_has_body();
  }
}
inline const std::string& InjectTextRequest::node() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.InjectTextRequest.node)
  return _internal_node();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InjectTextRequest::set_node(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kNode) {
    clear_body();

    set_has_node();
    _impl_.body_.node_.InitDefault();
  }
  _impl_.body_.node_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.InjectTextRequest.node)
}
inline std::string* InjectTextRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.InjectTextRequest.node)
  return _s;
}
inline const std::string& InjectTextRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (body_case() != kNode) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.body_.node_.Get();
}
inline void InjectTextRequest::_internal_set_node(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kNode) {
    clear_body();

    set_has_node();
    _impl_.body_.node_.InitDefault();
  }
  _impl_.body_.node_.Set(value, GetArena());
}
inline std::string* InjectTextRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() != kNode) {
    clear_body();

    set_has_node();
    _impl_.body_.node_.InitDefault();
  }
  return _impl_.body_.node_.Mutable( GetArena());
}
inline std::string* InjectTextRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.InjectTextRequest.node)
  if (body_case() != kNode) {
    return nullptr;
  }
  clear_has_body();
  return _impl_.body_.node_.Release();
}
inline void InjectTextRequest::set_allocated_node(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_body()) {
    clear_body();
  }
  if (value != nullptr) {
    set_has_node();
    _impl_.body_.node_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.InjectTextRequest.node)
}

// .thalamus_grpc.Text text = 2;
inline bool InjectTextRequest::has_text() const {
  return body_case() == kText;
}
inline bool InjectTextRequest::_internal_has_text() const {
  return body_case() == kText;
}
inline void InjectTextRequest::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void InjectTextRequest::clear_text() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (body_case() == kText) {
    if (GetArena() == nullptr) {
      delete _impl_.body_.text_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.body_.text_);
    }
    clear_has_body();
  }
}
inline ::thalamus_grpc::Text* InjectTextRequest::release_text() {
  // @@protoc_insertion_point(field_release:thalamus_grpc.InjectTextRequest.text)
  if (body_case() == kText) {
    clear_has_body();
    auto* temp = _impl_.body_.text_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.body_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::thalamus_grpc::Text& InjectTextRequest::_internal_text() const {
  return body_case() == kText ? *_impl_.body_.text_ : reinterpret_cast<::thalamus_grpc::Text&>(::thalamus_grpc::_Text_default_instance_);
}
inline const ::thalamus_grpc::Text& InjectTextRequest::text() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.InjectTextRequest.text)
  return _internal_text();
}
inline ::thalamus_grpc::Text* InjectTextRequest::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:thalamus_grpc.InjectTextRequest.text)
  if (body_case() == kText) {
    clear_has_body();
    auto* temp = _impl_.body_.text_;
    _impl_.body_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InjectTextRequest::unsafe_arena_set_allocated_text(::thalamus_grpc::Text* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_body();
  if (value) {
    set_has_text();
    _impl_.body_.text_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.InjectTextRequest.text)
}
inline ::thalamus_grpc::Text* InjectTextRequest::_internal_mutable_text() {
  if (body_case() != kText) {
    clear_body();
    set_has_text();
    _impl_.body_.text_ =
        ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::Text>(GetArena());
  }
  return _impl_.body_.text_;
}
inline ::thalamus_grpc::Text* InjectTextRequest::mutable_text() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::thalamus_grpc::Text* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.InjectTextRequest.text)
  return _msg;
}

inline bool InjectTextRequest::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void InjectTextRequest::clear_has_body() {
  _impl_._oneof_case_[0] = BODY_NOT_SET;
}
inline InjectTextRequest::BodyCase InjectTextRequest::body_case() const {
  return InjectTextRequest::BodyCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnalogResponse

// repeated double data = 1;
inline int AnalogResponse::_internal_data_size() const {
  return _internal_data().size();
}
inline int AnalogResponse::data_size() const {
  return _internal_data_size();
}
inline void AnalogResponse::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Clear();
}
inline double AnalogResponse::data(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogResponse.data)
  return _internal_data().Get(index);
}
inline void AnalogResponse::set_data(int index, double value) {
  _internal_mutable_data()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.AnalogResponse.data)
}
inline void AnalogResponse::add_data(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_data()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.AnalogResponse.data)
}
inline const ::google::protobuf::RepeatedField<double>& AnalogResponse::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.AnalogResponse.data)
  return _internal_data();
}
inline ::google::protobuf::RepeatedField<double>* AnalogResponse::mutable_data()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.AnalogResponse.data)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_data();
}
inline const ::google::protobuf::RepeatedField<double>&
AnalogResponse::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_;
}
inline ::google::protobuf::RepeatedField<double>* AnalogResponse::_internal_mutable_data() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.data_;
}

// repeated .thalamus_grpc.Span spans = 2;
inline int AnalogResponse::_internal_spans_size() const {
  return _internal_spans().size();
}
inline int AnalogResponse::spans_size() const {
  return _internal_spans_size();
}
inline void AnalogResponse::clear_spans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spans_.Clear();
}
inline ::thalamus_grpc::Span* AnalogResponse::mutable_spans(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.AnalogResponse.spans)
  return _internal_mutable_spans()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>* AnalogResponse::mutable_spans()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.AnalogResponse.spans)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spans();
}
inline const ::thalamus_grpc::Span& AnalogResponse::spans(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogResponse.spans)
  return _internal_spans().Get(index);
}
inline ::thalamus_grpc::Span* AnalogResponse::add_spans() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::thalamus_grpc::Span* _add = _internal_mutable_spans()->Add();
  // @@protoc_insertion_point(field_add:thalamus_grpc.AnalogResponse.spans)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>& AnalogResponse::spans() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.AnalogResponse.spans)
  return _internal_spans();
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>&
AnalogResponse::_internal_spans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spans_;
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>*
AnalogResponse::_internal_mutable_spans() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spans_;
}

// repeated uint64 sample_intervals = 3;
inline int AnalogResponse::_internal_sample_intervals_size() const {
  return _internal_sample_intervals().size();
}
inline int AnalogResponse::sample_intervals_size() const {
  return _internal_sample_intervals_size();
}
inline void AnalogResponse::clear_sample_intervals() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sample_intervals_.Clear();
}
inline ::uint64_t AnalogResponse::sample_intervals(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogResponse.sample_intervals)
  return _internal_sample_intervals().Get(index);
}
inline void AnalogResponse::set_sample_intervals(int index, ::uint64_t value) {
  _internal_mutable_sample_intervals()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.AnalogResponse.sample_intervals)
}
inline void AnalogResponse::add_sample_intervals(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_sample_intervals()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.AnalogResponse.sample_intervals)
}
inline const ::google::protobuf::RepeatedField<::uint64_t>& AnalogResponse::sample_intervals() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.AnalogResponse.sample_intervals)
  return _internal_sample_intervals();
}
inline ::google::protobuf::RepeatedField<::uint64_t>* AnalogResponse::mutable_sample_intervals()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.AnalogResponse.sample_intervals)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sample_intervals();
}
inline const ::google::protobuf::RepeatedField<::uint64_t>&
AnalogResponse::_internal_sample_intervals() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sample_intervals_;
}
inline ::google::protobuf::RepeatedField<::uint64_t>* AnalogResponse::_internal_mutable_sample_intervals() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sample_intervals_;
}

// bool channels_changed = 4;
inline void AnalogResponse::clear_channels_changed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_changed_ = false;
}
inline bool AnalogResponse::channels_changed() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.AnalogResponse.channels_changed)
  return _internal_channels_changed();
}
inline void AnalogResponse::set_channels_changed(bool value) {
  _internal_set_channels_changed(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.AnalogResponse.channels_changed)
}
inline bool AnalogResponse::_internal_channels_changed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_changed_;
}
inline void AnalogResponse::_internal_set_channels_changed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_changed_ = value;
}

// -------------------------------------------------------------------

// GraphRequest

// .thalamus_grpc.NodeSelector node = 1;
inline bool GraphRequest::has_node() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.node_ != nullptr);
  return value;
}
inline void GraphRequest::clear_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ != nullptr) _impl_.node_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::thalamus_grpc::NodeSelector& GraphRequest::_internal_node() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::thalamus_grpc::NodeSelector* p = _impl_.node_;
  return p != nullptr ? *p : reinterpret_cast<const ::thalamus_grpc::NodeSelector&>(::thalamus_grpc::_NodeSelector_default_instance_);
}
inline const ::thalamus_grpc::NodeSelector& GraphRequest::node() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphRequest.node)
  return _internal_node();
}
inline void GraphRequest::unsafe_arena_set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.node_);
  }
  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:thalamus_grpc.GraphRequest.node)
}
inline ::thalamus_grpc::NodeSelector* GraphRequest::release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* released = _impl_.node_;
  _impl_.node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::thalamus_grpc::NodeSelector* GraphRequest::unsafe_arena_release_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.GraphRequest.node)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::thalamus_grpc::NodeSelector* temp = _impl_.node_;
  _impl_.node_ = nullptr;
  return temp;
}
inline ::thalamus_grpc::NodeSelector* GraphRequest::_internal_mutable_node() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.node_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::thalamus_grpc::NodeSelector>(GetArena());
    _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(p);
  }
  return _impl_.node_;
}
inline ::thalamus_grpc::NodeSelector* GraphRequest::mutable_node() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::thalamus_grpc::NodeSelector* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.GraphRequest.node)
  return _msg;
}
inline void GraphRequest::set_allocated_node(::thalamus_grpc::NodeSelector* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.node_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.node_ = reinterpret_cast<::thalamus_grpc::NodeSelector*>(value);
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.GraphRequest.node)
}

// repeated int32 channels = 2;
inline int GraphRequest::_internal_channels_size() const {
  return _internal_channels().size();
}
inline int GraphRequest::channels_size() const {
  return _internal_channels_size();
}
inline void GraphRequest::clear_channels() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_.Clear();
}
inline ::int32_t GraphRequest::channels(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphRequest.channels)
  return _internal_channels().Get(index);
}
inline void GraphRequest::set_channels(int index, ::int32_t value) {
  _internal_mutable_channels()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.GraphRequest.channels)
}
inline void GraphRequest::add_channels(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channels()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.GraphRequest.channels)
}
inline const ::google::protobuf::RepeatedField<::int32_t>& GraphRequest::channels() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.GraphRequest.channels)
  return _internal_channels();
}
inline ::google::protobuf::RepeatedField<::int32_t>* GraphRequest::mutable_channels()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.GraphRequest.channels)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channels();
}
inline const ::google::protobuf::RepeatedField<::int32_t>&
GraphRequest::_internal_channels() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_;
}
inline ::google::protobuf::RepeatedField<::int32_t>* GraphRequest::_internal_mutable_channels() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channels_;
}

// uint64 bin_ns = 3;
inline void GraphRequest::clear_bin_ns() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bin_ns_ = ::uint64_t{0u};
}
inline ::uint64_t GraphRequest::bin_ns() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphRequest.bin_ns)
  return _internal_bin_ns();
}
inline void GraphRequest::set_bin_ns(::uint64_t value) {
  _internal_set_bin_ns(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.GraphRequest.bin_ns)
}
inline ::uint64_t GraphRequest::_internal_bin_ns() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bin_ns_;
}
inline void GraphRequest::_internal_set_bin_ns(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bin_ns_ = value;
}

// repeated string channel_names = 4;
inline int GraphRequest::_internal_channel_names_size() const {
  return _internal_channel_names().size();
}
inline int GraphRequest::channel_names_size() const {
  return _internal_channel_names_size();
}
inline void GraphRequest::clear_channel_names() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channel_names_.Clear();
}
inline std::string* GraphRequest::add_channel_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_channel_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:thalamus_grpc.GraphRequest.channel_names)
  return _s;
}
inline const std::string& GraphRequest::channel_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphRequest.channel_names)
  return _internal_channel_names().Get(index);
}
inline std::string* GraphRequest::mutable_channel_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.GraphRequest.channel_names)
  return _internal_mutable_channel_names()->Mutable(index);
}
inline void GraphRequest::set_channel_names(int index, const std::string& value) {
  _internal_mutable_channel_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::set_channel_names(int index, std::string&& value) {
  _internal_mutable_channel_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::set_channel_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_channel_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::set_channel_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_channel_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::set_channel_names(int index, absl::string_view value) {
  _internal_mutable_channel_names()->Mutable(index)->assign(
      value.data(), value.size());
  // @@protoc_insertion_point(field_set_string_piece:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::add_channel_names(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::add_channel_names(std::string&& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::add_channel_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::add_channel_names(const char* value, std::size_t size) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:thalamus_grpc.GraphRequest.channel_names)
}
inline void GraphRequest::add_channel_names(absl::string_view value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_channel_names()->Add()->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_add_string_piece:thalamus_grpc.GraphRequest.channel_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GraphRequest::channel_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.GraphRequest.channel_names)
  return _internal_channel_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GraphRequest::mutable_channel_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.GraphRequest.channel_names)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_channel_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GraphRequest::_internal_channel_names() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channel_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GraphRequest::_internal_mutable_channel_names() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.channel_names_;
}

// -------------------------------------------------------------------

// Span

// uint32 begin = 1;
inline void Span::clear_begin() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.begin_ = 0u;
}
inline ::uint32_t Span::begin() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Span.begin)
  return _internal_begin();
}
inline void Span::set_begin(::uint32_t value) {
  _internal_set_begin(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Span.begin)
}
inline ::uint32_t Span::_internal_begin() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.begin_;
}
inline void Span::_internal_set_begin(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.begin_ = value;
}

// uint32 end = 2;
inline void Span::clear_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = 0u;
}
inline ::uint32_t Span::end() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Span.end)
  return _internal_end();
}
inline void Span::set_end(::uint32_t value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Span.end)
}
inline ::uint32_t Span::_internal_end() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.end_;
}
inline void Span::_internal_set_end(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.end_ = value;
}

// string name = 3;
inline void Span::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Span::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Span.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Span::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Span.name)
}
inline std::string* Span::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Span.name)
  return _s;
}
inline const std::string& Span::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void Span::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* Span::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* Span::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Span.name)
  return _impl_.name_.Release();
}
inline void Span::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Span.name)
}

// -------------------------------------------------------------------

// GraphResponse

// repeated double bins = 1;
inline int GraphResponse::_internal_bins_size() const {
  return _internal_bins().size();
}
inline int GraphResponse::bins_size() const {
  return _internal_bins_size();
}
inline void GraphResponse::clear_bins() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.bins_.Clear();
}
inline double GraphResponse::bins(int index) const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphResponse.bins)
  return _internal_bins().Get(index);
}
inline void GraphResponse::set_bins(int index, double value) {
  _internal_mutable_bins()->Set(index, value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.GraphResponse.bins)
}
inline void GraphResponse::add_bins(double value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _internal_mutable_bins()->Add(value);
  // @@protoc_insertion_point(field_add:thalamus_grpc.GraphResponse.bins)
}
inline const ::google::protobuf::RepeatedField<double>& GraphResponse::bins() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.GraphResponse.bins)
  return _internal_bins();
}
inline ::google::protobuf::RepeatedField<double>* GraphResponse::mutable_bins()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.GraphResponse.bins)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_bins();
}
inline const ::google::protobuf::RepeatedField<double>&
GraphResponse::_internal_bins() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.bins_;
}
inline ::google::protobuf::RepeatedField<double>* GraphResponse::_internal_mutable_bins() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.bins_;
}

// repeated .thalamus_grpc.Span spans = 2;
inline int GraphResponse::_internal_spans_size() const {
  return _internal_spans().size();
}
inline int GraphResponse::spans_size() const {
  return _internal_spans_size();
}
inline void GraphResponse::clear_spans() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.spans_.Clear();
}
inline ::thalamus_grpc::Span* GraphResponse::mutable_spans(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.GraphResponse.spans)
  return _internal_mutable_spans()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>* GraphResponse::mutable_spans()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:thalamus_grpc.GraphResponse.spans)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_spans();
}
inline const ::thalamus_grpc::Span& GraphResponse::spans(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphResponse.spans)
  return _internal_spans().Get(index);
}
inline ::thalamus_grpc::Span* GraphResponse::add_spans() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::thalamus_grpc::Span* _add = _internal_mutable_spans()->Add();
  // @@protoc_insertion_point(field_add:thalamus_grpc.GraphResponse.spans)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>& GraphResponse::spans() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:thalamus_grpc.GraphResponse.spans)
  return _internal_spans();
}
inline const ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>&
GraphResponse::_internal_spans() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.spans_;
}
inline ::google::protobuf::RepeatedPtrField<::thalamus_grpc::Span>*
GraphResponse::_internal_mutable_spans() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.spans_;
}

// bool channels_changed = 3;
inline void GraphResponse::clear_channels_changed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_changed_ = false;
}
inline bool GraphResponse::channels_changed() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.GraphResponse.channels_changed)
  return _internal_channels_changed();
}
inline void GraphResponse::set_channels_changed(bool value) {
  _internal_set_channels_changed(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.GraphResponse.channels_changed)
}
inline bool GraphResponse::_internal_channels_changed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.channels_changed_;
}
inline void GraphResponse::_internal_set_channels_changed(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.channels_changed_ = value;
}

// -------------------------------------------------------------------

// Event

// bytes payload = 1;
inline void Event::clear_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.ClearToEmpty();
}
inline const std::string& Event::payload() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Event.payload)
  return _internal_payload();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Event::set_payload(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Event.payload)
}
inline std::string* Event::mutable_payload() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Event.payload)
  return _s;
}
inline const std::string& Event::_internal_payload() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.payload_.Get();
}
inline void Event::_internal_set_payload(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.Set(value, GetArena());
}
inline std::string* Event::_internal_mutable_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.payload_.Mutable( GetArena());
}
inline std::string* Event::release_payload() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Event.payload)
  return _impl_.payload_.Release();
}
inline void Event::set_allocated_payload(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.payload_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.payload_.IsDefault()) {
          _impl_.payload_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Event.payload)
}

// uint64 time = 2;
inline void Event::clear_time() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = ::uint64_t{0u};
}
inline ::uint64_t Event::time() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Event.time)
  return _internal_time();
}
inline void Event::set_time(::uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Event.time)
}
inline ::uint64_t Event::_internal_time() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.time_;
}
inline void Event::_internal_set_time(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.time_ = value;
}

// -------------------------------------------------------------------

// ObservableChange

// string address = 1;
inline void ObservableChange::clear_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.ClearToEmpty();
}
inline const std::string& ObservableChange::address() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ObservableChange.address)
  return _internal_address();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ObservableChange::set_address(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.ObservableChange.address)
}
inline std::string* ObservableChange::mutable_address() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.ObservableChange.address)
  return _s;
}
inline const std::string& ObservableChange::_internal_address() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.address_.Get();
}
inline void ObservableChange::_internal_set_address(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.Set(value, GetArena());
}
inline std::string* ObservableChange::_internal_mutable_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.address_.Mutable( GetArena());
}
inline std::string* ObservableChange::release_address() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.ObservableChange.address)
  return _impl_.address_.Release();
}
inline void ObservableChange::set_allocated_address(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.address_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.address_.IsDefault()) {
          _impl_.address_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.ObservableChange.address)
}

// string value = 2;
inline void ObservableChange::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.ClearToEmpty();
}
inline const std::string& ObservableChange::value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ObservableChange.value)
  return _internal_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ObservableChange::set_value(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.ObservableChange.value)
}
inline std::string* ObservableChange::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.ObservableChange.value)
  return _s;
}
inline const std::string& ObservableChange::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_.Get();
}
inline void ObservableChange::_internal_set_value(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.Set(value, GetArena());
}
inline std::string* ObservableChange::_internal_mutable_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.value_.Mutable( GetArena());
}
inline std::string* ObservableChange::release_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.ObservableChange.value)
  return _impl_.value_.Release();
}
inline void ObservableChange::set_allocated_value(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.value_.IsDefault()) {
          _impl_.value_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.ObservableChange.value)
}

// .thalamus_grpc.ObservableChange.Action action = 3;
inline void ObservableChange::clear_action() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = 0;
}
inline ::thalamus_grpc::ObservableChange_Action ObservableChange::action() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ObservableChange.action)
  return _internal_action();
}
inline void ObservableChange::set_action(::thalamus_grpc::ObservableChange_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ObservableChange.action)
}
inline ::thalamus_grpc::ObservableChange_Action ObservableChange::_internal_action() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::thalamus_grpc::ObservableChange_Action>(_impl_.action_);
}
inline void ObservableChange::_internal_set_action(::thalamus_grpc::ObservableChange_Action value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.action_ = value;
}

// uint64 id = 4;
inline void ObservableChange::clear_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t ObservableChange::id() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ObservableChange.id)
  return _internal_id();
}
inline void ObservableChange::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ObservableChange.id)
}
inline ::uint64_t ObservableChange::_internal_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.id_;
}
inline void ObservableChange::_internal_set_id(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.id_ = value;
}

// uint64 acknowledged = 5;
inline void ObservableChange::clear_acknowledged() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acknowledged_ = ::uint64_t{0u};
}
inline ::uint64_t ObservableChange::acknowledged() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.ObservableChange.acknowledged)
  return _internal_acknowledged();
}
inline void ObservableChange::set_acknowledged(::uint64_t value) {
  _internal_set_acknowledged(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.ObservableChange.acknowledged)
}
inline ::uint64_t ObservableChange::_internal_acknowledged() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.acknowledged_;
}
inline void ObservableChange::_internal_set_acknowledged(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.acknowledged_ = value;
}

// -------------------------------------------------------------------

// Notification

// .thalamus_grpc.Notification.Type type = 1;
inline void Notification::clear_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = 0;
}
inline ::thalamus_grpc::Notification_Type Notification::type() const {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Notification.type)
  return _internal_type();
}
inline void Notification::set_type(::thalamus_grpc::Notification_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:thalamus_grpc.Notification.type)
}
inline ::thalamus_grpc::Notification_Type Notification::_internal_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::thalamus_grpc::Notification_Type>(_impl_.type_);
}
inline void Notification::_internal_set_type(::thalamus_grpc::Notification_Type value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.type_ = value;
}

// string title = 2;
inline void Notification::clear_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.ClearToEmpty();
}
inline const std::string& Notification::title() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Notification.title)
  return _internal_title();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Notification::set_title(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Notification.title)
}
inline std::string* Notification::mutable_title() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Notification.title)
  return _s;
}
inline const std::string& Notification::_internal_title() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.title_.Get();
}
inline void Notification::_internal_set_title(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.Set(value, GetArena());
}
inline std::string* Notification::_internal_mutable_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.title_.Mutable( GetArena());
}
inline std::string* Notification::release_title() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Notification.title)
  return _impl_.title_.Release();
}
inline void Notification::set_allocated_title(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.title_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.title_.IsDefault()) {
          _impl_.title_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Notification.title)
}

// string message = 3;
inline void Notification::clear_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.ClearToEmpty();
}
inline const std::string& Notification::message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:thalamus_grpc.Notification.message)
  return _internal_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Notification::set_message(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:thalamus_grpc.Notification.message)
}
inline std::string* Notification::mutable_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:thalamus_grpc.Notification.message)
  return _s;
}
inline const std::string& Notification::_internal_message() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_.Get();
}
inline void Notification::_internal_set_message(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.Set(value, GetArena());
}
inline std::string* Notification::_internal_mutable_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_.Mutable( GetArena());
}
inline std::string* Notification::release_message() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:thalamus_grpc.Notification.message)
  return _impl_.message_.Release();
}
inline void Notification::set_allocated_message(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_.IsDefault()) {
          _impl_.message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:thalamus_grpc.Notification.message)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace thalamus_grpc


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::thalamus_grpc::Image_Format> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::thalamus_grpc::Image_Format>() {
  return ::thalamus_grpc::Image_Format_descriptor();
}
template <>
struct is_proto_enum<::thalamus_grpc::ObservableChange_Action> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::thalamus_grpc::ObservableChange_Action>() {
  return ::thalamus_grpc::ObservableChange_Action_descriptor();
}
template <>
struct is_proto_enum<::thalamus_grpc::Notification_Type> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::thalamus_grpc::Notification_Type>() {
  return ::thalamus_grpc::Notification_Type_descriptor();
}
template <>
struct is_proto_enum<::thalamus_grpc::Modalities> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::thalamus_grpc::Modalities>() {
  return ::thalamus_grpc::Modalities_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_thalamus_2eproto_2epb_2eh
